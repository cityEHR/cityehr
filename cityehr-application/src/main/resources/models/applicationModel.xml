<?xml version="1.0" encoding="UTF-8"?>
<!-- 
    *********************************************************************************************************
    cityEHR
    applicationModel.xml
    
    Xforms model containing stuff for managing the application and its information models.
    This model is loaded for cityEHRSignOn, cityEHRAdmin and cityEHRCohortSearch
    
    The actions defined here are used for the following administration tasks (in cityEHRAdmin)
    
        manageApplication
    
        
    
    Copyright (C) 2013-2021 John Chelsom.
    
    This program is free software; you can redistribute it and/or modify it under the terms of the
    GNU Lesser General Public License as published by the Free Software Foundation; either version
    2.1 of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU Lesser General Public License for more details.
    
    The full text of the license is available at http://www.gnu.org/copyleft/lesser.html
    **********************************************************************************************************
-->

<xf:model id="application-model" xmlns:xf="http://www.w3.org/2002/xforms"
    xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:xxf="http://orbeon.org/oxf/xml/xforms"
    xmlns:exforms="http://www.exforms.org/exf/1-0" xmlns:widget="http://orbeon.org/oxf/xml/widget"
    xmlns:fr="http://orbeon.org/oxf/xml/form-runner" xmlns:f="http://orbeon.org/oxf/xml/formatting"
    xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:exist="http://exist.sourceforge.net/NS/exist" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xxi="http://orbeon.org/oxf/xml/xinclude" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:math="http://exslt.org/math" xmlns:cda="urn:hl7-org:v3"
    xmlns:iso-13606="http://www.iso.org/iso-13606" xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:cityEHR="http://openhealthinformatics.org/ehr"
    xmlns:office2003Spreadsheet="urn:schemas-microsoft-com:office:spreadsheet"
    xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0"
    xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:svg="http://www.w3.org/2000/svg">


    <!-- Control of the application -->
    <xf:instance id="applicationControl-instance">
        <control xmlns="">
            <status model="application-model"/>
            <error/>

            <!-- Parameters for the importModel process -->
            <importModelParameters mergeCommonModel="true" mergeExistingModel="false"
                importMedia="false" importDirectories="false" rebuildDirectories="true">
                <applicationId/>
                <applicationIRI/>
                <specialtyId/>
                <classId/>
                <modelId/>
                <commonModelName/>
                <commonModelIRI/>
                <commonModelId/>
                <staticResourceLocation/>
                <baseLanguageCode/>
                <languageCode/>
            </importModelParameters>

            <!-- Parameters for the createApplication process -->
            <createApplicationParameters>
                <applicationId/>
                <applicationIRI/>
            </createApplicationParameters>

            <!-- Parameters for the importShippedResources process -->
            <importShippedResources>
                <languagePackFile last-modified-ms="" last-modified-date="" size="" path="" name=""/>
                <directoryFile last-modified-ms="" last-modified-date="" size="" path="" name=""/>
                <!--
                <mediaFile xsi:type="xs:base64Binary" last-modified-ms="" last-modified-date="" size="" path="" name="" content-type="" width=""
                    height="" elementIRI="" value=""/>
-->
                <mediaFile last-modified-ms="" last-modified-date="" size="" path="" name=""
                    content-type="" width="" height="" elementIRI="" value=""/>

                <letterTemplateFile path="" name="" content-type=""/>

                <imageMapFile last-modified-ms="" last-modified-date="" fileName="" path="" name=""
                    errorMessage=""/>
            </importShippedResources>

            <!-- Stored resources -->
            <storedResources>
                <letterTemplate value="" displayName="" errorMessage="">
                    <compositions all="true">
                        <!-- Insert composition elements that use this template -->
                    </compositions>
                    <!-- letterTemplateFile  is inserted here - holds the binary content -->
                    <!-- letterTemplateVariables  is inserted here - the list of variables extracted from the content -->
                </letterTemplate>
                <composition specialtyIRI="" compositionIRI="" displayName=""/>
                <svg xmlns="http://www.w3.org/2000/svg" id="" version="1.1" class="imageMap"
                    viewBox="" x="" y="" style=""/>
            </storedResources>

            <!-- Parameters for managing directories -->
            <directoryParameters>
                <status/>
                <!-- Template directory element, used to populate directoryList and commonModelDirectoryList -->
                <directory root="" displayName="" type="" key="" specialtyIRI="" commonModelIRI=""/>
                <!-- Templates for iso-13606:entry and iso-13606:element are inserted here -->
                <iso-13606:data xmlns="http://www.iso.org/iso-13606" code="" codeSystem="cityEHR"
                    value="" displayName=""/>
            </directoryParameters>

        </control>
    </xf:instance>

    <xf:instance id="applicationError-instance">
        <errorReport/>
    </xf:instance>

    <!-- === Utilities ===============================        
         ============================================= -->

    <!-- Application defined action to clear an element.
         Sets all attributes to ''
         Removes all child elements -->
    <xf:action ev:event="clear-element">
        <xxf:variable name="element" select="event('element')"/>

        <xf:action xxf:iterate="$element/@*">
            <xf:setvalue ref="." value="''"/>
        </xf:action>

        <xf:delete nodeset="$element/*"/>
    </xf:action>


    <!-- Application defined action to clear the lists of shipped resources -->
    <xf:action ev:event="clear-shippedResourceLists">
        <xf:delete nodeset="xxf:instance('shippedInformationModelList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('shippedLanguagePackList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('shippedDirectoryList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('shippedMediaList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('shippedImageMapFileList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('shippedLetterTemplateList-instance')/*"/>
    </xf:action>

    <!-- === Queries and lists ===============================        
         ===================================================== -->

    <!-- Load the queries from file.
         These return lists of applications, specialties, information models (Specialty and Class) and language packs -->
    <xf:instance id="applicationListXQuery-instance"
        src="oxf:/apps/ehr/xquery/applicationListXQuery.xml"/>
    <xf:instance id="specialtyListXQuery-instance"
        src="oxf:/apps/ehr/xquery/specialtyListXQuery.xml"/>
    <xf:instance id="informationModelListXQuery-instance"
        src="oxf:/apps/ehr/xquery/informationModelListXQuery.xml"/>
    <xf:instance id="languagePackListXQuery-instance"
        src="oxf:/apps/ehr/xquery/languagePackListXQuery.xml"/>

    <!-- Instances for lists.
         The lists are returned from queries.
         Instances contain an example of content, but this is replaced by the query results -->

    <!-- applicationList -->
    <xf:instance id="applicationList-instance">
        <list>
            <iso-13606:EHR_Extract id="#ISO-13606:EHR_Extract:cityEHR" displayName="cityEHR"
                commonModel="#ISO-13606:Folder:cityEHRBase"
                defaultSpecialty="#ISO-13606:Folder:FeatureDemo"
                xmlns:iso-13606="http://www.iso.org/iso-13606"/>
        </list>
    </xf:instance>

    <!-- specialtyList -->
    <xf:instance id="specialtyList-instance">
        <list>
            <iso-13606:Folder id="#ISO-13606:Folder:FeatureDemo" displayName="Feature Demo"/>
        </list>
    </xf:instance>

    <!-- informationModelList -->
    <xf:instance id="informationModelList-instance">
        <list>
            <informationModel>
                <specialtyIRI/>
                <specialtyDisplayName/>
                <modelIRI/>
                <informationModelType/>
                <modelDisplayName/>
                <handle/>
            </informationModel>
        </list>
    </xf:instance>

    <!-- languagePackList -->
    <xf:instance id="languagePackList-instance">
        <list>
            <languagePack>
                <languageCode/>
                <applicationIRI/>
                <specialtyIRI/>
                <modelIRI/>
                <handle/>
            </languagePack>
        </list>
    </xf:instance>



    <!-- === Shipped Applications ===============================        
         ======================================================== -->

    <!-- Application defined action to get the list of shipped applciations
         The assumption is that the shipped applications are in the resources/applications folder
         Each shipped application is in a directory named using the pattern:
         
         ISO-13606-EHR_Extract-cityEHR   
         
         dal-getStaticResourceList returns elements of the form
            <directory name="ISO-13606-EHR_Extract-cityEHR" path="ISO-13606-EHR_Extract-cityEHR" included="true"/>
    -->
    <xf:instance id="shippedApplicationList-instance">
        <shippedApplicationList/>
    </xf:instance>

    <xf:action ev:event="get-shippedApplicationList">
        <xxf:variable name="shippedApplicationList-instance"
            select="event('shippedApplicationList-instance')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation" select="'/applications'"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedApplicationList-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Remove any elements that don't match the pattern of shipped applications -->
        <xxf:variable name="applicationFolderPrefix"
            select="xxf:instance('view-parameters-instance')/applicationFolderPrefix"/>
        <xf:delete nodeset="xxf:instance('shippedApplicationList-instance')/file"/>
        <xf:delete
            nodeset="xxf:instance('shippedApplicationList-instance')/directory[not(starts-with(@name,$applicationFolderPrefix))]"/>


        <!--
        <xf:insert context="shippedApplicationList-instance" origin="xxf:instance('shippedApplicationList-instance')"/> 
        -->
    </xf:action>



    <!-- === Managing Applications =============================== 
         Task: manageApplication
         ========================================================= -->

    <!-- Application defined action to get list of installed applications -->
    <xf:action ev:event="get-applicationList">
        <xxf:variable name="status" select="event('status')"/>

        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="'/xmlstore/applications'"/>
            <xxf:context name="query" select="xxf:instance('applicationListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('applicationList-instance')"/>
            <xxf:context name="status" select="$status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to check the status of installed applications.
         If there are no applications installed, then create the default application,
         by loading its application-parameters and any shipped information models. -->
    <xf:action ev:event="check-application-status">
        <xxf:variable name="status" select="event('status')"/>

    </xf:action>

    <!-- Application defined action to get list of specialties for the specified application -->
    <xf:action ev:event="get-specialtyList">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/informationModel')"/>
            <xxf:context name="query" select="xxf:instance('specialtyListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('specialtyList-instance')"/>
            <xxf:context name="status" select="$status"/>
        </xf:dispatch>
    </xf:action>

    <!-- Application defined action to delete a specialty for the specified application -->
    <xf:action ev:event="delete-specialty">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="specialtyId" select="event('specialtyId')"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Set the location for the specialty in systemConfiguration and then delete it -->
        <xxf:variable name="systemConfigurationLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/',$specialtyId)"/>
        <xf:dispatch name="dal-delete" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$systemConfigurationLocation"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the location for the specialty informationModel and then delete it -->
        <xxf:variable name="informationModelLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/informationModel/',$specialtyId)"/>
        <xf:dispatch name="dal-delete" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$informationModelLocation"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the location for the specialty languagePack and then delete it -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/',$specialtyId)"/>
        <xf:dispatch name="dal-delete" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$informationModelLocation"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Load specialty list for the application -->
        <xf:dispatch name="get-specialtyList" target="application-model">
            <xxf:context name="applicationId" select="$applicationId"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>
    </xf:action>

    <!-- Application defined action to get list of information models for the specified application -->
    <xf:action ev:event="get-informationModelList">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/informationModel')"/>
            <xxf:context name="query" select="xxf:instance('informationModelListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('informationModelList-instance')"/>
            <xxf:context name="status" select="$status"/>
        </xf:dispatch>
    </xf:action>

    <!-- Application defined action to get list of language packs for the specified application -->
    <xf:action ev:event="get-languagePackList">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/languagePack')"/>
            <xxf:context name="query" select="xxf:instance('languagePackListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('languagePackList-instance')"/>
            <xxf:context name="status" select="$status"/>
        </xf:dispatch>
    </xf:action>



    <!-- === Creating Applications ===============================
         
         ======================================================== -->

    <!-- Application defined action to create a new application.
         Parameters for the new application have already been set up in working-application-parameters
         Set up importModelParameters for the new application
         Invoke get-defaultInformationModelList for the application
         Run the create-application process, as defined in view-parameters
         -->
    <xf:action ev:event="create-application">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="completionActionModel" select="event('completionActionModel')"/>
        <xxf:variable name="completionActionName" select="event('completionActionName')"/>

        <!-- Initialize parameters ready to import shipped models.
             Creates defaultInformationModelList which is passed as context to the create-application process -->
        <xf:dispatch name="initialize-importShippedResources" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
        </xf:dispatch>

        <!-- Set parameters to be used in the create-application process -->
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/createApplicationParameters/applicationId"
            value="$applicationId"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/createApplicationParameters/applicationIRI"
            value="$applicationIRI"/>

        <!-- Run the process to create a new application -->
        <xf:dispatch name="run-process" target="process-model">
            <xxf:context name="processName" select="'create-application'"/>
            <xxf:context name="contextSet"
                select="xxf:instance('defaultInformationModelList-instance')/file"/>
            <xxf:context name="completionActionModel" select="$completionActionModel"/>
            <xxf:context name="completionActionName" select="$completionActionName"/>
        </xf:dispatch>

    </xf:action>

    <!-- === create-application
         This process is defined in view-parameters.
         Invoked from the action create-application
         Parameters for the process are held in xxf:instance('applicationControl-instance')/createApplicationParameters.
         The application parameters for the new application must already be set in working-application-parameters
         Invoked with a contextSet which is a list of files holding any information models shipped for the application to be created.
         
         createApplication-saveParameters
         createApplication-import
            Invoke importShippedModels-import to:
              For each file in the contextSet:
                Read the file from disk
                Convert to OWL/XML
                Invoke the sub-process import-informationModel         
         createApplication-setApplicationList
         createApplication-setUserPermissions
         
        -->

    <!-- Application defined action to save application parameters
         An action in the create-application process. -->
    <xf:action ev:event="createApplication-saveParameters">
        <xxf:variable name="createApplicationParameters"
            select="xxf:instance('applicationControl-instance')/createApplicationParameters"/>
        <xxf:variable name="applicationIRI" select="$createApplicationParameters/applicationIRI"/>
        <xxf:variable name="applicationId" select="$createApplicationParameters/applicationId"/>


        <!-- The application parameters have been created in working-application-parameters.
             If not, then abort-process -->
        <xf:action
            if="xxf:instance('working-application-parameters-instance')/application/iso-13606:EHR_Extract/@id = $applicationIRI">
            <!-- Clear the version stamp (will get set on save) -->
            <xf:setvalue ref="xxf:instance('working-application-parameters-instance')/@version"
                value="''"/>

            <!-- Save the working-application-parameters -->
            <xf:dispatch name="save-application-parameters" target="configurationManagement-model">
                <xxf:context name="applicationId" select="$applicationId"/>
                <xxf:context name="parameters-instance"
                    select="xxf:instance('working-application-parameters-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Abort if something has gone wrong -->
        <xf:action
            if="xxf:instance('working-application-parameters-instance')/application/iso-13606:EHR_Extract/@id != $createApplicationParameters/applicationIRI
            or xxf:instance('applicationControl-instance')/status !=''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode" select="'bad-application-parameters'"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to import models on disk for the application.
         An action in the create-application process. 
         Is repeated for the context, which is the file containing the model
         Loads the model from disk
         Does not abort the process if there was an error, but the error will be reported in the executionLog -->
    <xf:action ev:event="createApplication-import">
        <xxf:variable name="file" select="event('context')"/>

        <xxf:variable name="fileName" select="$file/@name"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/createApplicationParameters/applicationIRI"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <xf:dispatch name="load-informationModel" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>



    <!-- Application defined action to import media shipped with the application.
         An action in the create-application process.
         -->
    <xf:action ev:event="createApplication-importMedia">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="classId" select="$importModelParameters/classId"/>

        <!-- Only for specialty models - classId is not set.
             Looks for media files in the default location as shipped with the cityEHR installation.
             Only need to do this once, when a shipped model is imported for the first time -->
        <xf:action if="$classId =''"> </xf:action>

    </xf:action>


    <!-- Application defined action to import directories shipped with the application.
        An action in the create-application process.
         -->
    <xf:action ev:event="createApplication-importDirectories">
        <!-- TBD -->
    </xf:action>


    <!-- Application defined action to set the application list (to include the new application).
         An action in the create-application process. -->
    <xf:action ev:event="createApplication-setApplicationList">
        <!-- Get the applicationList - which should now include the new application -->
        <xf:dispatch name="get-applicationList" target="application-model">
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>
    </xf:action>


    <!-- Application defined action to set permissions for the current user to access the new application.
         An action in the create-application process. -->
    <xf:action ev:event="createApplication-setUserPermissions">
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/createApplicationParameters/applicationIRI"/>

        <!-- Get entry for the new application from applicationList -->
        <xxf:variable name="newApplication"
            select="xxf:instance('applicationList-instance')/iso-13606:EHR_Extract[@id = $applicationIRI]"/>
        <!-- Remove new application from the profile for the current user -->
        <xf:delete
            nodeset="xxf:instance('user-instance')/applications/iso-13606:EHR_Extract[@id=$applicationIRI]"/>
        <!-- Insert the new application into the profile for the current user -->
        <xf:insert context="xxf:instance('user-instance')/applications"
            nodeset="iso-13606:EHR_Extract" origin="$newApplication" at="last()" position="after"/>
        <!-- Save the current user -->
        <xf:dispatch name="save-user-details" target="session-model"/>
    </xf:action>


    <!-- === Managing Directories ===============================
         These actions are for managing directories, which only happens in cityEHRSignOn, cityEHRAdmin (and cityEHRCohortSearch)
         Directory can be for an entry or element.
         Directories are defined for specialty models and stored in the configuration for the specialtyId.
         Any directories for the common model are generated by default in other specialties when they are merged.
         For any directories shared in this way, only the master copy in the common model is maintained by the user.
         
         There are three types of template used for managing directories:
            entryDirectory/elementDirectory - these are the directories that contain sets of entries or elements (read from static files)
            directoryControl-instance/template holds the entry or element (set from the data dictionary) that is held in the directory
            directoryControl-instance/templateValue holds a standard iso-13606:data element that is used to populate element directories
         ======================================================== -->

    <xf:instance id="directoryList-instance">
        <directoryList/>
    </xf:instance>

    <xf:instance id="commonModelDirectoryList-instance">
        <directoryList/>
    </xf:instance>

    <xf:instance id="directory-instance">
        <directory/>
    </xf:instance>

    <xf:instance id="workingDirectory-instance">
        <directory/>
    </xf:instance>

    <xf:instance id="directoryResource-instance">
        <directory/>
    </xf:instance>

    <xf:instance id="shippedDirectoryList-instance">
        <directoryList/>
    </xf:instance>


    <!-- Application defined action to initialize the list of shipped directories.
         Used in create-application and import-shippedResources.
         Gets the shippedDirectoryList -->
    <xf:action ev:event="initialize-shippedDirectoryList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/directories')"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedDirectoryList-instance')"/>
            <xxf:context name="fileTemplate"
                select="xxf:instance('applicationControl-instance')/importShippedResources/directoryFile"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to load a directory from disk.
         The directoryFileName is passed as a parameter 
         Locate directory on disk and into workingDirectory-instance
         Extract directory parameters - applicationIRI, specialtyIRI and languageCode
            -->
    <xf:action ev:event="load-directory-from-disk">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="fileName" select="event('fileName')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Filename must not be blank -->
        <xf:action if="$fileName !=''">
            <!-- Set the staticResourceLocation -->
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/directories/',$fileName)"/>

            <!-- Load the directory from disk -->
            <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource" select="xxf:instance('workingDirectory-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to set the list of directories in the dictionary.         
         Processes the modelDictionary-instance and builds the directoryList-instance
         Iterate through entries and elements in modelDictionary that are defined as directories.
         The template for the directoryList entries is in applicationControl-instance.
         Set root, displayName,type and key, then add to directoryList.
         -->
    <xf:action ev:event="set-directoryList">
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>
        <xxf:variable name="directoryList-instance" select="event('directoryList-instance')"/>

        <!-- Get the specialty from the modelDictionary -->
        <xxf:variable name="specialtyIRI" select="$dictionary-instance/@code"/>
        <xxf:variable name="commonModelIRI" select="$dictionary-instance/@commonModelCode"/>


        <!-- Clear the current list -->
        <xf:delete nodeset="$directoryList-instance/*"/>

        <!-- Template for directoryList entry -->
        <xxf:variable name="directory"
            select="xxf:instance('applicationControl-instance')/directoryParameters/directory"/>
        <xf:setvalue ref="$directory/@specialtyIRI" value="$specialtyIRI"/>
        <xf:setvalue ref="$directory/@commonModelIRI" value="$commonModelIRI"/>

        <!-- Entry directories.
             These have cityEHR:CRUD set to #CityEHR:EntryProperty:L or #CityEHR:EntryProperty:UL for look-up
             It is assumed that all dictionary entries are simpleType observations - if not then there is no directory.
             Entries may be aliased (so the root is different from the extension), but only the base entry has a directory.
             -->
        <xf:action
            xxf:iterate="$dictionary-instance/iso-13606:entryCollection/iso-13606:entry[@cityEHR:CRUD=('#CityEHR:EntryProperty:L','#CityEHR:EntryProperty:UL')]">
            <xxf:variable name="entry" select="."/>
            <xxf:variable name="observation" select="$entry/cda:component/cda:observation"/>

            <!-- There is only a directory for simple entries that are not aliased -->
            <xf:action
                if="exists($observation) and ($observation/cda:id/@root = $observation/cda:id/@extension)">

                <xf:setvalue ref="$directory/@root" value="$observation/cda:id/@root"/>
                <xf:setvalue ref="$directory/@displayName"
                    value="concat($observation/cda:code/@displayName,' (',substring-after($observation/cda:id/@root,'#ISO-13606:Entry:'),')')"/>
                <xf:setvalue ref="$directory/@type" value="'entry'"/>
                <xxf:variable name="sortCriteria" select="$entry/@cityEHR:sortCriteria"/>
                <xxf:variable name="key"
                    select="if (exists($sortCriteria)) then $sortCriteria else $entry/descendant::cda:value[@value][1]/@root"/>
                <xf:setvalue ref="$directory/@key" value="$key"/>

                <xf:insert context="$directoryList-instance" origin="$directory"/>
            </xf:action>
        </xf:action>

        <!-- Element directories
             These have cityEHR:elementType set to #CityEHR:ElementProperty:enumeratedDirectory -->
        <xf:action
            xxf:iterate="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedDirectory']">
            <xxf:variable name="element" select="."/>

            <xf:setvalue ref="$directory/@root" value="$element/@root"/>
            <xf:setvalue ref="$directory/@displayName"
                value="concat($element/@displayName,' (',substring-after($element/@root,'#ISO-13606:Element:'),')')"/>
            <xf:setvalue ref="$directory/@type" value="'element'"/>
            <xf:setvalue ref="$directory/@key" value="''"/>

            <xf:insert context="$directoryList-instance" origin="$directory"/>
        </xf:action>
    </xf:action>


    <!-- Application defined action to set the template entry/element for a directory.
         Uses the directory type and root passed in the directory parameter
         Note that the template is found in the modelDictionary using the @root, since aliased entries/elements can't have a directory of their own
         -->
    <xf:action ev:event="set-directory-template">
        <xxf:variable name="directory" select="event('directory')"/>
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>

        <xxf:variable name="directoryType" select="$directory/@type"/>
        <xxf:variable name="directoryRoot" select="$directory/@root"/>

        <!-- Clear existing templates -->
        <xf:delete
            nodeset="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:entry"/>
        <xf:delete
            nodeset="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:element"/>

        <!-- Entry directory -->
        <xf:action if="$directoryType='entry'">
            <xxf:variable name="entry"
                select="$dictionary-instance/iso-13606:entryCollection/iso-13606:entry[cda:component/cda:observation/cda:id/@root=$directoryRoot]"/>
            <xf:insert context="xxf:instance('applicationControl-instance')/directoryParameters"
                origin="$entry"/>
        </xf:action>

        <!-- Element directory -->
        <xf:action if="$directoryType='element'">
            <!-- Insert template.
                 This is the element definition from the dictionary that will be used for:
                    Setting up the directory if its a new one (i.e. not already saved in the xmlstore)
                    Checking that all defined values for the element have an item in the directory -->
            <xxf:variable name="element"
                select="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@root=$directoryRoot]"/>
            <xf:insert context="xxf:instance('applicationControl-instance')/directoryParameters"
                origin="$element"/>
        </xf:action>
    </xf:action>


    <!-- Application defined action to load a directory from the database.
              
         The directory passed as a parameter is located and loaded into workingDirectory-instance
         Then it is processed and saved (but only if processing resulted in changes)
         Finally sets the directory-instance passed as a parameter to the workingDirectory-instance
         
         The directory will exist in either the specialty or the common model (but never in both).
         So try to load first from the specialty and then from the common model.
         
            -->
    <xf:action ev:event="load-directory">
        <xxf:variable name="directory" select="event('directory')"/>
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="directory-instance" select="event('directory-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Get directory parameters -->
        <xxf:variable name="directoryType" select="$directory/@type"/>
        <xxf:variable name="directoryIRI" select="$directory/@root"/>
        <xxf:variable name="key" select="$directory/@key"/>
        <xxf:variable name="specialtyIRI" select="$directory/@specialtyIRI"/>
        <xxf:variable name="commonModelIRI" select="$directory/@commonModelIRI"/>

        <!-- Set ids from IRIs -->
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>
        <xxf:variable name="directoryId" select="replace(substring($directoryIRI,2),':','-')"/>
        <xxf:variable name="specialtyId" select="replace(substring($specialtyIRI,2),':','-')"/>
        <xxf:variable name="commonModelId" select="replace(substring($commonModelIRI,2),':','-')"/>

        <!-- Set templates for new items. -->
        <xf:dispatch name="set-directory-template" target="application-model">
            <xxf:context name="directory" select="$directory"/>
            <xxf:context name="dictionary-instance" select="$dictionary-instance"/>
        </xf:dispatch>

        <!-- If this is not the common model, then check for directory in common model.
             If directory exists, then job is done here - 
             common model directories are stored and maintained only in the common model -->
        <xf:action if="$specialtyId != $commonModelId">
            <xxf:variable name="directoryLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/',$commonModelId,'/directory/',$directoryId)"/>

            <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$directoryLocation"/>
                <xxf:context name="resource" select="xxf:instance('workingDirectory-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Only continue if this is the common model (in which case the commonModelId may be blank).***jc
             Or there is no common model directory (i.e. directory was not loaded for common model) -->
        <xf:action
            if="$specialtyId = $commonModelId  or xxf:instance('workingDirectory-instance')/name() != 'EHR_Extract'">
            <!-- Reset the status -->
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                value="''"/>

            <!-- Load the directory to workingDirectory-instance -->
            <xf:action>
                <xxf:variable name="directoryLocation"
                    select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/',$specialtyId,'/directory/',$directoryId)"/>

                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                    <xxf:context name="system" select="'ehr'"/>
                    <xxf:context name="storageLocation" select="$directoryLocation"/>
                    <xxf:context name="resource" select="xxf:instance('workingDirectory-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>
            </xf:action>

            <!-- If valid directory was not found, then load the template -->
            <!-- Entry - load the entry directory template-->
            <xf:action
                if="$directoryType='entry' and not(exists(xxf:instance('workingDirectory-instance')/iso-13606:entryCollection))">
                <xxf:variable name="staticResourceLocation"
                    select="'/templates/directoryEntryTemplate.xml'"/>

                <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
                    <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                    <xxf:context name="resource" select="xxf:instance('workingDirectory-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <xf:setvalue
                    ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                    value="'edited'"/>
            </xf:action>

            <!-- Element - load the element directory template -->
            <xf:action
                if="$directoryType='element'  and not(exists(xxf:instance('workingDirectory-instance')/iso-13606:elementCollection))">
                <xxf:variable name="staticResourceLocation"
                    select="'/templates/directoryElementTemplate.xml'"/>

                <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
                    <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                    <xxf:context name="resource" select="xxf:instance('workingDirectory-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <!-- Now insert the element for this directory.
                     Values for the element will be inserted as children. -->
                <xf:insert
                    context="xxf:instance('workingDirectory-instance')/iso-13606:elementCollection"
                    origin="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:element"/>

                <xf:setvalue
                    ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                    value="'edited'"/>
            </xf:action>

            <!-- Set up the directory
             But only if a valid directory or template was loaded
             Processing depends on the type of directory
             -->

            <!-- Entry directory.
             Check consistency - the entries in the loaded directory should match the entry in the model (which might have changed)
             If inconsistent, then fix the loaded directory.
             Set the key element for an entry directory and reset elementDisplayName in template
             If the key is an enumeratedValue, enumeratedClass or enumeratedDirectory 
             then the entry directory must contain an item for each value of the key
             and no entries with a key whose value is not defined -->
            <xf:action
                if="$directoryType='entry' and exists(xxf:instance('workingDirectory-instance')/iso-13606:entryCollection)">
                <!-- Get the first entry in the directory -->
                <xxf:variable name="firstEntry"
                    select="xxf:instance('workingDirectory-instance')/iso-13606:entryCollection/iso-13606:entry[1]"/>

                <!-- Only need to check consistency  if there are entries already stored for this directory -->
                <xf:action if="exists($firstEntry)">
                    <!-- Values in the first entry -->
                    <xxf:variable name="firstEntryValues" select="$firstEntry/descendant::cda:value"/>
                    <!-- Values in the template entry -->
                    <xxf:variable name="templateValues"
                        select="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:entry/descendant::cda:value"/>

                    <!-- Check that the directory entries stored is consistent with the entry in the dictionary.
                         This checks that the elements and element types are the same (assumes they are in the same order)
                     -->
                    <xxf:variable name="consistentDirectory"
                        select="if (string-join($templateValues/@extension,'') = string-join($firstEntryValues/@extension,'') and
                                string-join($templateValues/@cityEHR:elementType,'') = string-join($firstEntryValues/@cityEHR:elementType,'') and
                                string-join($templateValues/@xsi:type,'') = string-join($firstEntryValues/@xsi:type,''))
                                then true() else false()"/>

                    <!-- Check the directory size -->
                    <xxf:variable name="directorySize"
                        select="count(xxf:instance('workingDirectory-instance')/iso-13606:entryCollection/iso-13606:entry)"/>
                    <xxf:variable name="maxDirectorySizeForRebuildParameter"
                        select="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageDirectory/maxDirectorySizeForRebuild"/>
                    <xxf:variable name="maxDirectorySizeForRebuild"
                        select="if (exists($maxDirectorySizeForRebuildParameter) and $maxDirectorySizeForRebuildParameter castable as xs:integer) then $maxDirectorySizeForRebuildParameter else '0'"/>

                    <!-- If the stored directory is inconsistent and there aren't too many entries, then it needs to be rebuilt before any other processing.
                         Iterate through the stored entries
                         Set up the template entry with values of any stored values that exist in the template
                         Then remove the directory entry and replace with the new one (from the template)-->
                    <xf:action
                        if="not($consistentDirectory) and (xs:integer($directorySize) lt xs:integer($maxDirectorySizeForRebuild))">
                        <!-- Set the status - directory will be edited -->
                        <xf:setvalue
                            ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                            value="'edited'"/>

                        <!-- Iterate through the entries -->
                        <xf:action
                            xxf:iterate="xxf:instance('workingDirectory-instance')/iso-13606:entryCollection/iso-13606:entry">
                            <xxf:variable name="directoryEntry" select="."/>

                            <!-- Reset the template on each iteration -->
                            <xf:dispatch name="set-directory-template" target="application-model">
                                <xxf:context name="directory" select="$directory"/>
                                <xxf:context name="dictionary-instance"
                                    select="$dictionary-instance"/>
                            </xf:dispatch>

                            <xxf:variable name="templateEntry"
                                select="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:entry"/>

                            <!-- Iterate through elements in the template - use descendant:: so that we find elements in clusters
                             Set value if there is one already set in the directory entry.
                             Also set the elementDisplayName and displayName
                             Note that the template has been reset on each iteration, so need to access the values directly, rather than use the templateValues variable
                             There may be clusters in the template or the directory entry.
                             These do not affect the values - the elementIRIs must be unique, regardless of whether in a cluster or not -->
                            <xf:action xxf:iterate="$templateEntry/descendant::cda:value[@value]">
                                <xxf:variable name="templateValue" select="."/>
                                <xxf:variable name="templateValueIRI"
                                    select="$templateValue/@extension"/>

                                <!-- Get the matching value in the directoryEntry.
                                     This must have the same path of cda:value elements (so will find the correct value in clusters).
                                     There should only be one, but don't assume this. -->
                                <xxf:variable name="directoryValue"
                                    select="$directoryEntry/descendant::cda:value[@value][@extension = $templateValueIRI][1]"/>

                                <xf:action if="exists($directoryValue)">
                                    <xf:setvalue ref="$templateValue/@value"
                                        value="$directoryValue/@value"/>
                                    <xf:setvalue ref="$templateValue/@displayName"
                                        value="$directoryValue/@displayName"/>
                                    <xf:setvalue ref="$templateValue/@cityEHR:elementDisplayName"
                                        value="$directoryValue/@cityEHR:elementDisplayName"/>
                                </xf:action>
                            </xf:action>

                            <!-- Template is now ready to replace the directory entry.
                             Need to do this without disturbing the cda:entry container in the directory
                             So first delete the contents of the directory entry, then insert the contents of the template
                             Only need to run through the top level of cda:values (descendants of clusters will get inserted with their parent)
                             Make sure the order of the values is maintained by inserting at last() -->
                            <xf:delete nodeset="$directoryEntry/*"/>

                            <xf:action xxf:iterate="$templateEntry/*">
                                <xxf:variable name="templateContent" select="."/>
                                <xf:insert context="$directoryEntry" nodeset="*"
                                    origin="$templateContent" at="last()" position="after"/>
                            </xf:action>
                        </xf:action>

                    </xf:action>

                    <!-- Report directory that was too large to be rebuilt.
                         Message will only get displayed when importing a model and rebuilding directories -->
                    <xf:action
                        if="not($consistentDirectory) and not(xs:integer($directorySize) lt xs:integer($maxDirectorySizeForRebuild))">
                        <!-- TBD -->
                    </xf:action>
                </xf:action>

                <!-- Get the key element -->
                <xxf:variable name="keyElement"
                    select="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@root=$key]"/>

                <!-- Check the key values - these must come from the defined set for 
                     enumeratedValue, enumeratedCalculatedValue, enumeratedClass or enumeratedDirectory
                     Can only set up if the key exists (which it should) -->
                <xf:action if="exists($keyElement)">
                    <xxf:variable name="keyType" select="$keyElement/@cityEHR:elementType"/>

                    <xf:action
                        if="$keyType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:enumeratedCalculatedValue','#CityEHR:ElementProperty:enumeratedClass','#CityEHR:ElementProperty:enumeratedDirectory')">

                        <!-- Key is enumeratedDirectory type.
                             Load directory for the key to directoryResource-instance
                             Note that this is looking for the directory for the key value, so use a local directoryId.
                             Also note that the key directory may be in the common model -->
                        <xf:action if="$keyType='#CityEHR:ElementProperty:enumeratedDirectory'">
                            <xxf:variable name="directoryId"
                                select="replace(substring($key,2),':','-')"/>

                            <!-- First try the common model -->
                            <xf:action>
                                <xxf:variable name="directoryResourceLocation"
                                    select="concat('/xmlstore/',$applicationId,'/systemConfiguration/',$commonModelId,'/directory/',$directoryId)"/>

                                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                                    <xxf:context name="system" select="'ehr'"/>
                                    <xxf:context name="storageLocation"
                                        select="$directoryResourceLocation"/>
                                    <xxf:context name="resource"
                                        select="xxf:instance('directoryResource-instance')"/>
                                    <xxf:context name="status"
                                        select="xxf:instance('applicationControl-instance')/status"
                                    />
                                </xf:dispatch>
                            </xf:action>

                            <!-- Try the specialty model, if key directory was not found in common model -->
                            <xf:action
                                if="not(exists(xxf:instance('directoryResource-instance')/iso-13606:elementCollection))">
                                <xxf:variable name="directoryResourceLocation"
                                    select="concat('/xmlstore/',$applicationId,'/systemConfiguration/',$specialtyId,'/directory/',$directoryId)"/>

                                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                                    <xxf:context name="system" select="'ehr'"/>
                                    <xxf:context name="storageLocation"
                                        select="$directoryResourceLocation"/>
                                    <xxf:context name="resource"
                                        select="xxf:instance('directoryResource-instance')"/>
                                    <xxf:context name="status"
                                        select="xxf:instance('applicationControl-instance')/status"
                                    />
                                </xf:dispatch>
                            </xf:action>
                        </xf:action>

                        <!-- Key is enumeratedClass type
                             Load class dictionary for key to directoryResource-instance.
                             Class dictionaries for a specialty are merged with the common model, if one exists. 
                             But the class may not be defined in the specialty, only the common model.
                             So check the specialty first, then the common model
                             The classIRI is found in the first value of the key element.
                             Note that the class dictionary may be in the common model, so check that first. -->
                        <xf:action if="$keyType='#CityEHR:ElementProperty:enumeratedClass'">
                            <xxf:variable name="classIRI"
                                select="$keyElement/iso-13606:data[1]/@value"/>
                            <xxf:variable name="classId"
                                select="replace(substring($classIRI,2),':','-')"/>

                            <!-- First try the specialty model -->
                            <xf:action>
                                <xxf:variable name="directoryResourceLocation"
                                    select="concat('/xmlstore/',$applicationId,'/systemConfiguration/',$specialtyId,'/dictionary/',$classId)"/>

                                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                                    <xxf:context name="system" select="'ehr'"/>
                                    <xxf:context name="storageLocation"
                                        select="$directoryResourceLocation"/>
                                    <xxf:context name="resource"
                                        select="xxf:instance('directoryResource-instance')"/>
                                    <xxf:context name="status"
                                        select="xxf:instance('applicationControl-instance')/status"
                                    />
                                </xf:dispatch>
                            </xf:action>

                            <!-- Try the common model, if the class dictionary was not found in specialty model -->
                            <xf:action
                                if="xxf:instance('directoryResource-instance')/name() != 'EHR_Extract'">
                                <xxf:variable name="directoryResourceLocation"
                                    select="concat('/xmlstore/',$applicationId,'/systemConfiguration/',$commonModelId,'/dictionary/',$classId)"/>

                                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                                    <xxf:context name="system" select="'ehr'"/>
                                    <xxf:context name="storageLocation"
                                        select="$directoryResourceLocation"/>
                                    <xxf:context name="resource"
                                        select="xxf:instance('directoryResource-instance')"/>
                                    <xxf:context name="status"
                                        select="xxf:instance('applicationControl-instance')/status"
                                    />
                                </xf:dispatch>
                            </xf:action>
                        </xf:action>

                        <!-- Get list of key values - depends on the type of the key.
                             If enumeratedValue or enumeratedCalculatedValue then values are in the keyElement from the specialty dictionary.
                             If enumeratedDirectory then values are from the directory loaded to directoryResource-instance
                             If enumeratedClass then values are from the class dictionary loaded to directoryResource-instance. -->
                        <xxf:variable name="keyValueList"
                            select="if ($keyType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:enumeratedCalculatedValue')) then $keyElement/iso-13606:data/@value 
                            else if ($keyType='#CityEHR:ElementProperty:enumeratedDirectory') then xxf:instance('directoryResource-instance')//iso-13606:element/iso-13606:data/@value 
                            else if ($keyType='#CityEHR:ElementProperty:enumeratedClass') then distinct-values(xxf:instance('directoryResource-instance')//iso-13606:data/@value) 
                            else ()"/>

                        <!-- Iterate through entries in the directory, removing any that do not have a key in the keyValueList. -->
                        <xf:action
                            xxf:iterate="xxf:instance('workingDirectory-instance')/iso-13606:entryCollection/iso-13606:entry">
                            <xxf:variable name="entry" select="."/>
                            <xxf:variable name="keyValue"
                                select="$entry/cda:component/cda:observation/descendant::cda:value[@root=$key]/@value"/>
                            <!-- Delete entry if key value is not in the keyValueList -->
                            <xf:action if="not($keyValue=$keyValueList)">
                                <xf:delete nodeset="$entry"/>
                                <xf:setvalue
                                    ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                                    value="'edited'"/>
                            </xf:action>
                        </xf:action>

                        <!-- Run through the enumerated values and add an entry for any that do not already exist.
                             Note that $keyValueList will be empty unless set corectly above 
                             If there is an entry in the deletedEntries section then it is restored (TBD) -->
                        <xxf:variable name="templateEntry"
                            select="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:entry"/>
                        <xf:action xxf:iterate="$keyValueList">
                            <xxf:variable name="keyValue" select="."/>

                            <!-- Insert new entry from template, if needed.
                                 There is only one entry with a value -->
                            <xf:action
                                if="not(exists(xxf:instance('workingDirectory-instance')/iso-13606:entryCollection/iso-13606:entry/descendant::cda:value[@root=$key][@value=$keyValue]))">
                                <!-- Set key value for new entry -->
                                <xf:setvalue
                                    ref="$templateEntry/descendant::cda:value[@root=$key]/@value"
                                    value="$keyValue"/>
                                <xf:insert
                                    context="xxf:instance('workingDirectory-instance')/iso-13606:entryCollection"
                                    nodeset="iso-13606:entry" origin="$templateEntry" at="last()"
                                    position="after"/>

                                <xf:setvalue
                                    ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                                    value="'edited'"/>
                            </xf:action>
                        </xf:action>

                    </xf:action>
                </xf:action>

            </xf:action>


            <!-- Element directory
                 Check definition of element directory with values specified in the information model -->
            <xf:action
                if="$directoryType='element' and exists(xxf:instance('workingDirectory-instance')/iso-13606:elementCollection)">
                <!-- Check that element directory contains all values specified in the information model.
                     These are available through the templateElement which has been set up above. -->
                <xxf:variable name="definedValues"
                    select="xxf:instance('applicationControl-instance')/directoryParameters/iso-13606:element/iso-13606:data"/>

                <!-- If defined value does not exist then add a value for the element in the directory -->
                <xf:action xxf:iterate="$definedValues">
                    <xxf:variable name="value" select="."/>
                    <xf:action
                        if="not(exists(xxf:instance('workingDirectory-instance')/iso-13606:elementCollection/iso-13606:element/iso-13606:data[@value=$value/@value]))">
                        <xf:insert
                            context="xxf:instance('workingDirectory-instance')/iso-13606:elementCollection/iso-13606:element"
                            nodeset="iso-13606:data" origin="$value" at="last()" position="after"/>
                        <xf:setvalue
                            ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                            value="'edited'"/>
                    </xf:action>
                </xf:action>
            </xf:action>

            <!-- Save directory if it has been changed -->
            <xf:action
                if="xxf:instance('applicationControl-instance')/directoryParameters/status='edited'">
                <xf:dispatch name="save-directory" target="application-model">
                    <xxf:context name="directory" select="$directory"/>
                    <xxf:context name="directory-instance"
                        select="xxf:instance('workingDirectory-instance')"/>
                    <xxf:context name="applicationIRI" select="$applicationIRI"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>
            </xf:action>
        </xf:action>

        <!-- Set the return directory-instance, set from workingDirectory-instance -->
        <xf:insert nodeset="$directory-instance" origin="xxf:instance('workingDirectory-instance')"/>

    </xf:action>


    <!-- Application defined action to save a directory.
         Directory will be stored for either the common model or the specialty, depending on whether there is already a directory stored there.
        
         The directory is held in directory-instance - details of the directory are in the directory parameter.
         Check the format of the directory before saving
         Uses the applicationIRI passed as a parameters
         Uses specialtyIRI and commonModelIRI as set in the directory
         directoryList-instance and commonModelDirectoryList-instance must already be built for the specialtyIRI and commonModelIRI
         -->
    <xf:action ev:event="save-directory">
        <xxf:variable name="directory" select="event('directory')"/>
        <xxf:variable name="directory-instance" select="event('directory-instance')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Get directory parameters -->
        <xxf:variable name="directoryType" select="$directory/@type"/>
        <xxf:variable name="directoryIRI" select="$directory/@root"/>
        <xxf:variable name="key" select="$directory/@key"/>
        <xxf:variable name="specialtyIRI" select="$directory/@specialtyIRI"/>
        <xxf:variable name="commonModelIRI" select="$directory/@commonModelIRI"/>

        <!-- Set ids from IRIs -->
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>
        <xxf:variable name="directoryId" select="replace(substring($directoryIRI,2),':','-')"/>
        <xxf:variable name="specialtyId" select="replace(substring($specialtyIRI,2),':','-')"/>
        <xxf:variable name="commonModelId" select="replace(substring($commonModelIRI,2),':','-')"/>

        <!-- Check that directory-instance contains a directory.
             Could do some more checking here on type and IRI -->
        <xxf:variable name="validDirectory"
            select="if  ($directory-instance/name()='EHR_Extract') then true() else false()"/>

        <!-- Directory not valid - set status -->
        <xf:action if="not($validDirectory)">
            <xf:setvalue ref="$status" value="'invalidDirectoryNotSaved'"/>
        </xf:action>

        <!-- Directory is valid - continue with save operation -->
        <xf:action if="$validDirectory">
            <xxf:variable name="errorCode"
                select="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageDirectory/errorCode"/>

            <!-- Use the directoryId for setting the directoryLocation -->
            <xxf:variable name="commonModelDirectoryLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/',$commonModelId,'/directory/',$directoryId)"/>
            <xxf:variable name="specialtyDirectoryLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/',$specialtyId,'/directory/',$directoryId)"/>

            <!-- The directory is saved in either the specialty or the common model.
                 (But the specialtyIRU may be the same as the commonModelIRI, when saving for the common model).
                 If the commonModel directory exists, then use commonModelId, otherwise specialtyId -->
            <xf:dispatch name="resource-exists" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$commonModelDirectoryLocation"/>
                <xxf:context name="result"
                    select="xxf:instance('applicationControl-instance')/directoryParameters/status"
                />
            </xf:dispatch>

            <xxf:variable name="directoryLocation"
                select="if (xxf:instance('applicationControl-instance')/directoryParameters/status='true') then $commonModelDirectoryLocation else $specialtyDirectoryLocation"/>

            <!-- entry directory -->
            <xf:action if="$directoryType='entry'">

                <!-- Check that key values are unique and not blank -->
                <xf:action
                    xxf:iterate="$directory-instance/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation/descendant::cda:value[@value][@root=$key]">
                    <xxf:variable name="value" select="."/>
                    <xxf:variable name="count"
                        select="count($directory-instance/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation/descendant::cda:value[@root=$key][@value=$value/@value])"/>
                    <xf:setvalue ref="$value/@code"
                        value="if ($count gt 1 or $value/@value='') then $errorCode else ''"/>
                </xf:action>
                <!-- If directory is good then set default values
                     All codes have been set to '' - don't need codes for directory elements -->
                <xf:action
                    if="not($directory-instance/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation/descendant::cda:value[@root=$key]/@code=$errorCode)">
                    <!-- Set default values (actually should be done already when values were entered, but do again here, just in case) -->
                    <xf:action
                        xxf:iterate="$directory-instance/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation/descendant::cda:value[@value][@displayName='']">
                        <xxf:variable name="value" select="."/>
                        <xf:setvalue ref="$value/@displayName" value="$value/@value"/>
                    </xf:action>

                    <!-- Write the directory to xmlstore -->
                    <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                        <xxf:context name="system" select="'ehr'"/>
                        <xxf:context name="storageLocation" select="$directoryLocation"/>
                        <xxf:context name="resource" select="$directory-instance"/>
                        <xxf:context name="status"
                            select="xxf:instance('applicationControl-instance')/status"/>
                    </xf:dispatch>

                    <!-- Reset status -->
                    <xf:setvalue
                        ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                        value="''"/>
                </xf:action>
                <!-- There is an error -->
                <xf:action
                    if="xxf:instance('directory-instance')/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation/descendant::cda:value/@code=$errorCode">
                    <!-- TBD -->
                </xf:action>
            </xf:action>

            <!-- element directory -->
            <xf:action if="$directoryType='element'">

                <!-- Set default values.
                     If value is blank then set to the displayName -->
                <xf:action
                    xxf:iterate="$directory-instance/iso-13606:elementCollection/iso-13606:element/iso-13606:data[@value='']">
                    <xxf:variable name="value" select="."/>
                    <xf:setvalue ref="$value/@value" value="$value/@displayName"/>
                </xf:action>

                <!-- Check that values are unique and displayNames are not blank -->
                <xf:action
                    xxf:iterate="$directory-instance/iso-13606:elementCollection/iso-13606:element/iso-13606:data">
                    <xxf:variable name="value" select="."/>
                    <xxf:variable name="count"
                        select="count($directory-instance/iso-13606:elementCollection/iso-13606:element/iso-13606:data[@value=$value/@value])"/>
                    <xf:setvalue ref="$value/@code"
                        value="if ($count gt 1 or $value/@displayName='') then $errorCode else ''"/>
                </xf:action>

                <!-- If directory is good then write to xmlstore
                     All codes have been set to '' - don't need codes for directory elements.
                     Unless there is an error (code will be set, but the driectory is not saved) -->
                <xf:action
                    if="not($directory-instance/iso-13606:elementCollection/iso-13606:element/iso-13606:data/@code=$errorCode)">
                    <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                        <xxf:context name="system" select="'ehr'"/>
                        <xxf:context name="storageLocation" select="$directoryLocation"/>
                        <xxf:context name="resource" select="$directory-instance"/>
                        <xxf:context name="status"
                            select="xxf:instance('applicationControl-instance')/status"/>
                    </xf:dispatch>

                    <!-- Reset edit status -->
                    <xf:setvalue
                        ref="xxf:instance('applicationControl-instance')/directoryParameters/status"
                        value="''"/>
                </xf:action>

                <!-- There is an error -->
                <xf:action if="$directory-instance/descendant::iso-13606:data/@code=$errorCode">
                    <!-- TBD -->
                </xf:action>
            </xf:action>

        </xf:action>
    </xf:action>


    <!-- Application defined action to rebuild directory from dictionary default values.
         Any values in the dictionary are inserted to replace those in the directory.
         This can be used if the default values change in the information model and need to be applied to the stored directory.
         (Default is that any existing values in the directory are not changed.)                 
         The current directory is passed as a parameter and is loaded in directory-instance
         
         ***JC This needs work - its not right ***
            -->
    <xf:action ev:event="rebuild-directory">

        <!-- the directoryIRI is set for the current (loaded) directory -->
        <xxf:variable name="directoryIRI"
            select="xxf:instance('control-instance')/manageDirectory/directoryIRI"/>
        <!-- The templateElement contains the element for the current directory, as defined in the data dictionary -->
        <xxf:variable name="directoryElement"
            select="xxf:instance('control-instance')/manageDirectory/templateElement/iso-13606:element"/>

        <!-- Iterate through values in the directoryElement
                     If value exists in the stored directory then delete it.
                     Insert the value from the directoryElement -->
        <xf:action xxf:iterate="$directoryElement/iso-13606:data">
            <xxf:variable name="directoryElementValue" select="."/>
            <!-- Remove value, if it exists, which it should -->
            <xf:delete
                nodeset="xxf:instance('directory-instance')/iso-13606:elementCollection/iso-13606:element/iso-13606:data[@value=$directoryElementValue/@value]"/>
            <!-- Insert value from dictionary -->
            <xf:insert
                context="xxf:instance('directory-instance')/iso-13606:elementCollection/iso-13606:element"
                nodeset="iso-13606:data" origin="$directoryElementValue" at="last()"
                position="after"/>
        </xf:action>

        <!-- Rebuild done - now save the directory -->
        <xf:dispatch name="save-directory" target="application-model">
            <xxf:context name="directory" select="$directory"/>
            <xxf:context name="directory-instance" select="xxf:instance('directory-instance')"/>
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to rebuild all directories.
         Uses the list already set up in directoryList-instance
         -->
    <xf:action ev:event="rebuild-directories">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>
        <xxf:variable name="directoryList-instance" select="event('directoryList-instance')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>

        <!-- Element and entry directory lists -->
        <xxf:variable name="elementDirectoryList"
            select="$directoryList-instance/directory[@type='element'][@root!='']"/>
        <xxf:variable name="entryDirectoryList"
            select="$directoryList-instance/directory[@type='entry'][@root!='']"/>

        <!-- Iterate through Element and Entry directories.
             Need to process the elements first, since an entry directory may have an enumeratedDirectory as its key -->
        <xf:action xxf:iterate="$elementDirectoryList | $entryDirectoryList">
            <xxf:variable name="directory" select="."/>

            <!-- Load directory rebuilds and saves as necessary.
                 directory-instance is a return parameter (not used). -->
            <xf:dispatch name="load-directory" target="application-model">
                <xxf:context name="directory" select="$directory"/>
                <xxf:context name="dictionary-instance" select="$dictionary-instance"/>
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="languageCode" select="$languageCode"/>
                <xxf:context name="directory-instance" select="xxf:instance('directory-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

        </xf:action>
    </xf:action>


    <!-- ========= Application Letter Templates ============== 
         ===================================================== -->

    <!-- Instance to hold binary letterTemplate for storage/load -->
    <xf:instance id="application-letterTemplateBinary-instance">
        <document/>
    </xf:instance>
    <xf:bind nodeset="xxf:instance('application-letterTemplateBinary-instance')"
        type="xs:base64Binary"/>

    <!-- List of shipped binary letter templates (.odt or .docx) -->
    <xf:instance id="shippedLetterTemplateList-instance">
        <letterTemplateList/>
    </xf:instance>

    <!-- Instance to hold letterTemplate for creation -->
    <xf:instance id="application-letterTemplate-instance">
        <letterTemplate/>
    </xf:instance>

    <!-- Instance to hold letterTemplateFile for creation -->
    <xf:instance id="application-letterTemplateFile-instance">
        <letterTemplateFile/>
    </xf:instance>
    <xf:bind nodeset="xxf:instance('application-letterTemplateFile-instance')"
        type="xs:base64Binary"/>

    <!-- get-storedLetterTemplateList is defined in dictionaryModel -->

    <!-- Application defined action to initialize the list of shipped templates.
         Used in create-application and 
         Gets the shippedLetterTemplateList in shippedLetterTemplateList-instance 
         Templates can be .odt or .docx-->
    <xf:action ev:event="initialize-shippedLetterTemplateList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/letterTemplates')"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedLetterTemplateList-instance')"/>
            <xxf:context name="fileTemplate"
                select="xxf:instance('applicationControl-instance')/importShippedResources/letterTemplateFile"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to load a letterTemplate file from disk.
         The letterTemplate fileName is passed as a parameter 
         This is for shipped templates, so the fileName is relative to the shipped letterTemplate location
         Locate letterTemplate on disk and load into application-letterTemplateBinary-instance
         -->
    <xf:action ev:event="load-letterTemplateBinary-from-disk">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="fileName" select="event('fileName')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Filename must not be blank -->
        <xf:action if="$fileName !=''">
            <!-- Set the staticResourceLocation -->
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/letterTemplates/',$fileName)"/>

            <!-- Load the letter template from disk -->
            <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource"
                    select="xxf:instance('application-letterTemplateBinary-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>
        </xf:action>

        <!-- Filename was blank -->
        <xf:action if="$fileName =''">
            <xf:setvalue ref="$status" value="'letterTemplateBinary-fileName-not-set'"/>
        </xf:action>

    </xf:action>


    <!-- Application defined action to create a new letter letterTemplateFile in application-letterTemplateFile-instance
         This creates an empty letterTemplateFile containing with no binary content
         -->
    <xf:action ev:event="create-letterTemplateFile">
        <xxf:variable name="letterTemplateFilename" select="event('letterTemplateFilename')"/>
        <xxf:variable name="letterTemplateContentType"
            select="if (exists(event('letterTemplateContentType'))) then event('letterTemplateContentType') else ''"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Set up the application-letterTemplateFile-instance using the template -->
        <xf:insert nodeset="xxf:instance('application-letterTemplateFile-instance')"
            origin="xxf:instance('applicationControl-instance')/importShippedResources/letterTemplateFile"/>

        <!-- Set the filename in the letterTemplateFile
             Path is also set, even though it doesn't get used, so that upload control works in cityEHRAdmin -->
        <xf:setvalue ref="xxf:instance('application-letterTemplateFile-instance')/@name"
            value="$letterTemplateFilename"/>
        <xf:setvalue ref="xxf:instance('application-letterTemplateFile-instance')/@path"
            value="$letterTemplateFilename"/>

        <!-- Set the content-type in the letterTemplateFile -->
        <xf:setvalue ref="xxf:instance('application-letterTemplateFile-instance')/@content-type"
            value="$letterTemplateContentType"/>

    </xf:action>


    <!-- Application defined action to create a new letter template in application-letterTemplate-instance
         Note that the id of the letterTemplate is "value" 
         (so that templates can be selected by the user from a standard balue/displayName list)
         This creates a letter template containing the letterTemplateFile passed as a parameter
         The template is created in application-letterTemplate-instance -->
    <xf:action ev:event="create-letterTemplate">
        <xxf:variable name="value"
            select="if (exists(event('value'))) then normalize-space(event('value')) else ''"/>
        <xxf:variable name="displayName"
            select="if (exists(event('displayName'))) then normalize-space(event('displayName')) else ''"/>
        <xxf:variable name="letterTemplateFile" select="event('letterTemplateFile')"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Set up application-letterTemplate-instance -->
        <xf:insert nodeset="xxf:instance('application-letterTemplate-instance')"
            origin="xxf:instance('applicationControl-instance')/storedResources/letterTemplate"/>

        <!-- Set value and displayName, which may be blank as parameters -->
        <xxf:variable name="timeStamp"
            select="replace(replace(string(current-dateTime()),':','-'),'\+','*')"/>
        <xxf:variable name="defaultValue"
            select="concat(xxf:instance('view-parameters-instance')/userId,xxf:instance('view-parameters-instance')/idSeparator,$timeStamp)"/>
        <xf:setvalue ref="xxf:instance('application-letterTemplate-instance')/@value"
            value="if ($value='') then $defaultValue else $value"/>
        <xf:setvalue ref="xxf:instance('application-letterTemplate-instance')/@displayName"
            value="$displayName"/>

        <!--  Run pipeline to extract variables from the letterTemplateFile.
              Returns a <letterTemplateVariables> element -->
        <xxf:variable name="xsltPipeline"
            select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/extractTemplateVariables.xpl')"/>
        <xxf:variable name="letterTemplateVariables"
            select="xxf:call-xpl($xsltPipeline, 'instance',  $letterTemplateFile, 'data')"/>

        <!-- Insert the letterTemplateVariables -->
        <xf:delete
            nodeset="xxf:instance('application-letterTemplate-instance')/letterTemplateVariables"/>
        <xf:insert context="xxf:instance('application-letterTemplate-instance')"
            origin="$letterTemplateVariables"/>

        <!-- Insert the letterTemplateFile -->
        <xf:delete nodeset="xxf:instance('application-letterTemplate-instance')/letterTemplateFile"/>
        <xf:insert context="xxf:instance('application-letterTemplate-instance')"
            origin="$letterTemplateFile"/>

    </xf:action>


    <!-- Application defined action to add a new letter template to the storedLetterTemplateList
         This creates an empty letter template.
         The template is added to storedLetterTemplateList-instance -->
    <xf:action ev:event="add-letterTemplate">
        <!-- Create an empty letterTemplateFile in application-letterTemplateFile-instance -->
        <xf:dispatch name="create-letterTemplateFile" target="application-model">
            <xxf:context name="letterTemplateFilename" select="''"/>
            <xxf:context name="letterTemplateContentType" select="''"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set up new letter template name -->
        <xxf:variable name="timeStamp"
            select="replace(replace(string(current-dateTime()),':','-'),'\+','*')"/>
        <xxf:variable name="letterTemplateName"
            select="concat(xxf:instance('view-parameters-instance')/userId,xxf:instance('view-parameters-instance')/idSeparator,$timeStamp)"/>

        <!-- Create the letter template in application-letterTemplate-instance -->
        <xf:dispatch name="create-letterTemplate" target="application-model">
            <xxf:context name="value" select="$letterTemplateName"/>
            <xxf:context name="displayName" select="$letterTemplateName"/>
            <xxf:context name="letterTemplateFile"
                select="xxf:instance('application-letterTemplateFile-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Add the new letter template to storedLetterTemplateList -->
        <xf:insert context="xxf:instance('storedLetterTemplateList-instance')" nodeset="*"
            origin="xxf:instance('application-letterTemplate-instance')" at="1" position="before"/>

    </xf:action>


    <!-- Application defined action to set the binary format of a letter letterTemplate.
         Invoked by importShippedResources-importLetterTemplates 
         Or from cityEHRAdmin when user uploads a new letter template binary.
         The binary content may be as shipped on disk (in application-letterTemplateBinary-instance)
         Or as loaded by the user in cityEHRAdmin 
         The content-type attribute in the letterTemplate/letterTemplateFile must already be set
         Sets the errorMessage in the template if the content-type is not supprted
         -->
    <xf:action ev:event="set-letterTemplateBinaryContent">
        <xxf:variable name="letterTemplate" select="event('letterTemplate')"/>
        <xxf:variable name="letterTemplateBinaryContent"
            select="event('letterTemplateBinaryContent')"/>

        <!-- Supported mime types are defined in view-parameters -->
        <xxf:variable name="supportedTypes"
            select="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageLetterTemplates/templateContent/mime/@type"/>

        <!-- Reset errorMessage -->
        <xf:setvalue ref="$letterTemplate/@errorMessage" value="''"/>

        <!-- Clear the letterTemplateFile and set errorMessage if content-type is not supported -->
        <xf:action if="not($letterTemplate/letterTemplateFile/@content-type=$supportedTypes)">
            <xf:setvalue ref="$letterTemplate/letterTemplateFile" value="''"/>
            <xf:setvalue ref="$letterTemplate/@errorMessage"
                value="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageLetterTemplates/templateContent/@displayName"
            />
        </xf:action>

        <!-- Content type is supported -->
        <xf:action if="$letterTemplate/letterTemplateFile/@content-type=$supportedTypes">

            <!--  Run pipeline to normalize variables in the letterTemplateFile.
                  Returns a <document> element with the updated binary -->
            <xxf:variable name="xsltPipeline"
                select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/normalizeTemplateVariables.xpl')"/>
            <xxf:variable name="normlaizedBinaryContent"
                select="xxf:call-xpl($xsltPipeline, 'instance',  $letterTemplateBinaryContent, 'data')"/>

            <!-- Set the binary comtent -->
            <xf:setvalue ref="$letterTemplate/letterTemplateFile" value="$normlaizedBinaryContent"/>

            <!--  Run pipeline to extract variables from the letterTemplateFile.
                  Returns a <letterTemplateVariables> element -->
            <xxf:variable name="xsltPipeline"
                select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/extractTemplateVariables.xpl')"/>
            <xxf:variable name="letterTemplateVariables"
                select="xxf:call-xpl($xsltPipeline, 'instance',  $normlaizedBinaryContent, 'data')"/>

            <!-- Insert the letterTemplateVariables -->
            <xf:delete nodeset="$letterTemplate/letterTemplateVariables"/>
            <xf:insert context="$letterTemplate" origin="$letterTemplateVariables"/>
        </xf:action>
    </xf:action>

    <!-- Application defined action to save a letter template.
         Only save the template if its content-type of letterTemplateFile is supported.
         If not, then just set the errorMessage and don't save
         -->
    <xf:action ev:event="save-letterTemplate">
        <xxf:variable name="letterTemplate" select="event('letterTemplate')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Can only save if id is set -->
        <xf:action if="$letterTemplate/@value !=''">
            <!-- Save to xmlstore -->
            <xxf:variable name="templateLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/letterTemplates/',$letterTemplate/@value)"/>

            <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$templateLocation"/>
                <xxf:context name="resource" select="$letterTemplate"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to delete a letter template.
         Assume that this action has been confirmed
         -->
    <xf:action ev:event="delete-letterTemplate">
        <xxf:variable name="letterTemplateId" select="event('letterTemplateId')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Delete the letterTemplate in the database.
             Only if letterTemplateId is set -->
        <xf:action if="$letterTemplateId != ''">
            <xxf:variable name="templateLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/letterTemplates/',$letterTemplateId)"/>
            <xf:dispatch name="dal-delete" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$templateLocation"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to add a composition to a letter template.
         An empty composition association is added, then the template is saved
         -->
    <xf:action ev:event="add-letterTemplateComposition">
        <xxf:variable name="letterTemplate" select="event('letterTemplate')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="specialtyIRI" select="event('specialtyIRI')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xxf:variable name="compositionTemplate"
            select="xxf:instance('applicationControl-instance')/storedResources/composition"/>
        <xf:setvalue ref="$compositionTemplate/@specialtyIRI" value="$specialtyIRI"/>

        <!-- Add the empty composition association -->
        <xf:insert context="$letterTemplate/compositions" origin="$compositionTemplate"/>

        <!-- Save the letter template -->
        <xf:dispatch name="save-letterTemplate" target="application-model">
            <xxf:context name="letterTemplate" select="$letterTemplate"/>
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
        </xf:dispatch>

    </xf:action>


    <!-- ========= Application Media ========================= 
         ===================================================== -->

    <xf:instance id="shippedMediaList-instance">
        <mediaList/>
    </xf:instance>

    <xf:instance id="storedMediaList-instance">
        <mediaList/>
    </xf:instance>
    <xf:bind nodeset="xxf:instance('storedMediaList-instance')/*" type="xs:base64Binary"/>

    <!-- Instance to hold media for storage/load -->
    <xf:instance id="application-media-instance">
        <image/>
    </xf:instance>
    <xf:bind nodeset="xxf:instance('application-media-instance')" type="xs:base64Binary"/>

    <!-- Instance to hold media information-->
    <xf:instance id="application-mediaInformation-instance">
        <image/>
    </xf:instance>

    <xf:instance id="storedMediaListXQuery-instance"
        src="oxf:/apps/ehr/xquery/storedMediaListXQuery.xml"/>


    <!-- Application defined action to initialize the list of shipped media.
         Used in create-application and import-shippedResources.
         Gets the shippedMediaList in shippedMediaList-instance -->
    <xf:action ev:event="initialize-shippedMediaList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/media')"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedMediaList-instance')"/>
            <xxf:context name="fileTemplate"
                select="xxf:instance('applicationControl-instance')/importShippedResources/mediaFile"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to load a media file from disk.
         The media fileName is passed as a parameter 
         This is for shipped media, so the fileName is relative to the shipped media location
         Locate media on disk and load into application-media-instance
         -->
    <xf:action ev:event="load-media-from-disk">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="fileName" select="event('fileName')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Filename must not be blank -->
        <xf:action if="$fileName !=''">
            <!-- Set the staticResourceLocation -->
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/media/',$fileName)"/>

            <!-- Load the media from disk -->
            <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource" select="xxf:instance('application-media-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>
        </xf:action>

    </xf:action>


    <!-- Application defined action to reload shipped media from disk.
         Uses the name for the mediaFile which was set when originally loaded from disk (includes the full filename with extension) -->
    <xf:action ev:event="reload-shippedMedia">
        <xxf:variable name="applicationIRI"
            select="xxf:instance('control-instance')/managedApplication/applicationIRI"/>

        <!-- Get the list of media shipped for this application -->
        <xf:dispatch name="initialize-shippedMediaList" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
        </xf:dispatch>

        <!-- Iterate through the media files, load and save to the database -->
        <xf:action xxf:iterate="xxf:instance('shippedMediaList-instance')/mediaFile">
            <xxf:variable name="mediaFile" select="."/>
            <xxf:variable name="fileName" select="$mediaFile/@name"/>

            <!-- Load the media from disk 
                 The media is loaded to application-media-instance -->
            <xf:dispatch name="load-media-from-disk" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="fileName" select="$fileName"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- If the media was loaded -->
            <xf:action if="xxf:instance('applicationControl-instance')/status=''">
                <xf:setvalue ref="$mediaFile/@path" value="if (.='') then $mediaFile/@name else ."/>

                <xf:dispatch name="save-media" target="application-model">
                    <xxf:context name="mediaFile" select="$mediaFile"/>
                    <xxf:context name="media-instance"
                        select="xxf:instance('application-media-instance')"/>
                    <xxf:context name="applicationIRI" select="$applicationIRI"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>
            </xf:action>

        </xf:action>

    </xf:action>


    <!-- Application defined action to load media into application-media-instance
         The mediaFile is passed as a parameter 
         The media is read from the database into application-media-instance.
         -->
    <xf:action ev:event="load-mediaInstance">
        <xxf:variable name="elementIRI" select="event('elementIRI')"/>
        <xxf:variable name="value" select="event('value')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Clear the value of the application-media-instance, in case it doesn't load.
             (It won't load if it hasn't previously been configured) -->
        <xf:setvalue ref="xxf:instance('application-media-instance')" value="''"/>
        <xf:delete nodeset="xxf:instance('application-media-instance')/*"/>

        <!-- Set the mediaName -->
        <xxf:variable name="mediaFilenameSeparator"
            select="xxf:instance('view-parameters-instance')/mediaFilenameSeparator"/>
        <xxf:variable name="elementId" select="substring-after($elementIRI,'#ISO-13606:Element:')"/>
        <xxf:variable name="mediaName" select="concat($elementId,$mediaFilenameSeparator,$value)"/>

        <xxf:variable name="mediaLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/media/',$mediaName)"/>

        <!-- Load the image from the database -->
        <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$mediaLocation"/>
            <xxf:context name="resource" select="xxf:instance('application-media-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to load a media file from the database.
         The mediaFile is passed as a parameter 
         Load media from database into application-media-instance.
         Then set mediaFile attributes and base64 content
         -->
    <xf:action ev:event="load-mediaFile">
        <xxf:variable name="mediaFile" select="event('mediaFile')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>

        <!-- Load the image from the database - in application-media-instance -->
        <xf:dispatch name="load-mediaInstance" target="application-model">
            <xxf:context name="elementIRI" select="$mediaFile/@elementIRI"/>
            <xxf:context name="value" select="$mediaFile/@value"/>
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
        </xf:dispatch>

        <!-- Set the attributes.
             These are attrbutes in the application-media-instance returned  -->
        <xf:action xxf:iterate="xxf:instance('application-media-instance')/@*">
            <xxf:variable name="attribute" select="."/>
            <xxf:variable name="attributeName" select="$attribute/name()"/>

            <xxf:variable name="mediaFileAttribute" select="$mediaFile/@*[name()=$attributeName]"/>
            <xf:setvalue ref="$mediaFileAttribute" value="$attribute"/>
        </xf:action>

        <!-- Now set the image as binary value of mediaFile
             If the image was loaded -->
        <xf:action
            if="xxf:instance('applicationControl-instance')/status='' and xxf:instance('application-media-instance') !=''">
            <xf:setvalue ref="$mediaFile"
                value="if (xxf:instance('application-media-instance') castable as xs:base64Binary) then xs:base64Binary(xxf:instance('application-media-instance')) else ''"
            />
        </xf:action>

    </xf:action>

    <!-- Application defined action to save a media file to the database.
         The mediaFile is passed as a parameter 
         The binary image is already set as the mediaFile content
         -->
    <xf:action ev:event="save-mediaFile">
        <xxf:variable name="mediaFile" select="event('mediaFile')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="elementIRI" select="$mediaFile/@elementIRI"/>
        <xxf:variable name="value" select="$mediaFile/@value"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Can only save if the media element and value are set -->
        <xf:action if="$elementIRI !='' and $value !=''">
            <!-- Set the mediaName -->
            <xxf:variable name="mediaFilenameSeparator"
                select="xxf:instance('view-parameters-instance')/mediaFilenameSeparator"/>
            <xxf:variable name="elementId"
                select="substring-after($elementIRI,'#ISO-13606:Element:')"/>
            <xxf:variable name="mediaName"
                select="concat($elementId,$mediaFilenameSeparator,$value)"/>

            <!-- Having used the path for the upload, then reset to the uploaded fileName
                (This gets displayed in the upload control, so is more useful than the temporary upload path) -->
            <xf:setvalue ref="$mediaFile/@path" value="$mediaName"/>

            <xxf:variable name="mediaLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/media/',$mediaName)"/>
            <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$mediaLocation"/>
                <xxf:context name="resource" select="$mediaFile"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

        </xf:action>

    </xf:action>

    <!-- Application defined action to save media to the database.
         This is used when media are loaded from disk.
         Media will be stored for the application (shared across all specialties).
        
         The media content is held in media-instance - details of the media are in the mediaFile parameter.
         Uses the applicationIRI passed as a parameter
         -->
    <xf:action ev:event="save-media">
        <xxf:variable name="mediaFile" select="event('mediaFile')"/>
        <xxf:variable name="media-instance" select="event('media-instance')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- The base64 value of the media is set from media-instance.
             But ony if it is passed as a parameter-->
        <xf:action if="exists($media-instance)">
            <xf:setvalue ref="$mediaFile" value="$media-instance"/>
        </xf:action>

        <!-- The name returned for the mediaFile may contain an extension (.png, .jpg, etc) which we don't want.
             So extract the name without an extension -->
        <xxf:variable name="mediaName" select="tokenize($mediaFile/@name,'\.')[1]"/>

        <!-- Set the Element Id and value from the mediaFile name.
             The name should be of the form [ElementId]-xxx-[Value] eg. letterHeadLogo-xxx-cityEHR
             where -xxx- is the mediaFilenameSeparator (defined in view-parameters and used to name shipped resources)
             Only save the media if the name is of the correct format -->
        <xxf:variable name="mediaFilenameSeparator"
            select="xxf:instance('view-parameters-instance')/mediaFilenameSeparator"/>
        <xxf:variable name="mediaNameTokens" select="tokenize($mediaName,$mediaFilenameSeparator)"/>
        <xxf:variable name="elementId" select="$mediaNameTokens[1]"/>
        <xxf:variable name="value" select="$mediaNameTokens[2]"/>

        <xf:action if="count($mediaNameTokens)=2 and $elementId!='' and $value!=''">
            <xf:setvalue ref="$mediaFile/@elementIRI"
                value="concat('#ISO-13606:Element:',$elementId)"/>
            <xf:setvalue ref="$mediaFile/@value" value="$value"/>

            <!-- Write the media to xmlstore -->
            <xxf:variable name="mediaLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/media/',$mediaName)"/>

            <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$mediaLocation"/>
                <xxf:context name="resource" select="$mediaFile"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>


    <!-- Application defined action to get the list of stored media for a set of entries.
         Actually, gets all the media for the applicationIRI - doesn't use entryList
         2022-11-10 Not used anywhere -->
    <xf:action ev:event="get-storedMediaList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="entryList" select="event('entryList')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xxf:variable name="mediaLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/media')"/>

        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$mediaLocation"/>
            <xxf:context name="query" select="xxf:instance('storedMediaListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('storedMediaList-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to load all media for a dictionary.
         The dictionary is passed as the dictionary-instance parameter.
         Media are stored for the application. so are not specific to any one specialty.
         The media are created as a set of <media/> elements in storedMediaList-instance
         Media elements are contents of entries with Image rendition
         The element is defined by its root, its values by the enumerated values of its extension
    -->
    <xf:action ev:event="load-dictionaryMedia">
        <xxf:variable name="applicationIRI"
            select="if (not(exists(event('applicationIRI'))) or event('applicationIRI')='') then xxf:instance('view-parameters-instance')/applicationIRI else event('applicationIRI')"/>
        <xxf:variable name="specialtyIRI" select="event('specialtyIRI')"/>
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>
        <xxf:variable name="directoryElements-instance" select="event('directoryElements-instance')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Media elements can be of any type (old way until 2025-05-18)
             From 2025-05-18 media elements are of type Name
             The root of the element is the elementIRI used to identify the mediaFile
             The root element should have an extension of either an enumeratedValue, calculatedEnumeratedValue or enumeratedDirectory type element that defines the values -->
        <!-- Old way - until 2025-05-18 -->
        <!--
        <xxf:variable name="dictionaryMediaElementList"
            select="distinct-values($dictionary-instance/iso-13606:entryCollection/iso-13606:entry[@cityEHR:rendition='#CityEHR:EntryProperty:Image']//cda:value/@root)"/>
 -->
        <!-- Since 2025-05-18 -->
        <xxf:variable name="dictionaryMediaElementList"
            select="distinct-values($dictionary-instance/iso-13606:elementCollection/iso-13606:element[@xsi:type='xs:Name']/@root)"/>


        <!-- Clear out the storedMediaList-instance -->
        <xf:delete nodeset="xxf:instance('storedMediaList-instance')/*"/>
        <xxf:variable name="mediaFileTemplate"
            select="xxf:instance('applicationControl-instance')/importShippedResources/mediaFile"/>

        <!-- Create the mediaList -->
        <xf:action xxf:iterate="$dictionaryMediaElementList">
            <xxf:variable name="mediaElementIRI" select="."/>
            <xxf:variable name="mediaElement"
                select="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@root=$mediaElementIRI]"/>

            <xxf:variable name="mediaValueElementIRI" select="$mediaElement/@extension"/>
            <xxf:variable name="mediaValueElement"
                select="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@root=$mediaValueElementIRI]"/>

            <xxf:variable name="mediaValueElementType"
                select="$mediaValueElement/@cityEHR:elementType"/>

            <!-- Values are either from enumeratedValue or enumeratedDirectory -->
            <xxf:variable name="mediaElementValueList"
                select="if ($mediaValueElementType='#CityEHR:ElementProperty:enumeratedValue') then $mediaValueElement/iso-13606:data
                else if ($mediaValueElementType='#CityEHR:ElementProperty:enumeratedDirectory') then $directoryElements-instance/iso-13606:elementCollection/iso-13606:element[@root=$mediaValueElementIRI]/iso-13606:data else ()"/>

            <!-- Add mediaFile for each value of the enumeratedValue or enumeratedDirectory element 
                 Iterate through the values -->
            <xf:action xxf:iterate="$mediaElementValueList">
                <xxf:variable name="value" select="./@value"/>

                <!-- Insert the mediaFile -->
                <xf:insert context="xxf:instance('storedMediaList-instance')" nodeset="*"
                    origin="$mediaFileTemplate" at="1" position="before"/>
                <xxf:variable name="mediaFile"
                    select="xxf:instance('storedMediaList-instance')/mediaFile[1]"/>

                <xf:setvalue ref="$mediaFile/@elementIRI" value="$mediaElementIRI"/>
                <xf:setvalue ref="$mediaFile/@value" value="$value"/>

                <!-- Load the media from the database -->
                <xf:dispatch name="load-mediaFile" target="application-model">
                    <xxf:context name="mediaFile" select="$mediaFile"/>
                    <xxf:context name="applicationIRI" select="$applicationIRI"/>
                </xf:dispatch>
            </xf:action>

        </xf:action>

    </xf:action>


    <!-- Application defined action to save all media for a dictionary.
         The dictionary is passed as the dictionary-instance parameter.
         The media are set as the content of media type elements (base64 binary)
         Media are stored for the application. so are not specific to any one specialty -->
    <xf:action ev:event="save-dictionaryMedia">
        <xxf:variable name="applicationIRI"
            select="if (not(exists(event('applicationIRI'))) or event('applicationIRI')='') then xxf:instance('view-parameters-instance')/applicationIRI else event('applicationIRI')"/>
        <xxf:variable name="dictionary-instance" select="event('dictionary-instance')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xxf:variable name="mediaElementList"
            select="$dictionary-instance/iso-13606:elementCollection/iso-13606:element[@xsi:type='xs:base64Binary'][@cityEHR:elementType!='#CityEHR:ElementProperty:patientMedia']"/>

        <xf:action xxf:iterate="$mediaElementList">
            <xxf:variable name="mediaElement" select="."/>
            <xxf:variable name="mediaElementIRI" select="$mediaElement/@extension"/>
            <xxf:variable name="mediaElementId"
                select="replace(substring($mediaElementIRI,2),':','-')"/>

            <!-- Set location of image for saving. -->
            <xxf:variable name="mediaStorageLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/media/',$mediaElementId)"/>

            <!-- Set up application-image-instance -->
            <xf:setvalue ref="xxf:instance('application-media-instance')" value="$mediaElement"/>

            <!-- Store the image -->
            <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$mediaStorageLocation"/>
                <xxf:context name="resource" select="xxf:instance('application-media-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('dictionaryControl-instance')/status"/>
            </xf:dispatch>

        </xf:action>

    </xf:action>


    <!-- Application defined action to get information for a mediaFile 
         The path in the mediaFile must be set to the location of a resource on the file system.
         Path is of the form returned by the xf:upload control
         file:/user/tmp/fileNeame.ext
         
         Information is returned to application-mediaInformation-instance, then set in the mediaFile
         -->
    <xf:action ev:event="set-mediaFileInformation">
        <xxf:variable name="mediaFile" select="event('mediaFile')"/>
        <xxf:variable name="resourceLocation" select="$mediaFile/@path"/>

        <xf:action if="starts-with($resourceLocation,'file:')">
            <!-- Get file name and directory -->
            <xxf:variable name="fileName" select="tokenize($resourceLocation,'/')[last()]"/>
            <xxf:variable name="fileDirectory"
                select="substring-before($resourceLocation,concat('/',$fileName))"/>

            <!-- Get the resource list, which should just return one file element -->
            <xf:dispatch name="dal-getResourceList" target="databaseAccessLayer-model">
                <xxf:context name="resourceLocation" select="$fileDirectory"/>
                <xxf:context name="resourcePattern" select="$fileName"/>
                <xxf:context name="resourceList-instance"
                    select="xxf:instance('application-mediaInformation-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- Should return a directory element, with single file element child
                 (see dal-getResourceList for the specification of the return format -->
            <xxf:variable name="file"
                select="xxf:instance('application-mediaInformation-instance')//file[1]"/>

            <!-- Set the attributes of the mediaFile
                 These may be attrbutes on the file element returned, or elements in the image-metadata
                 If neither, then leave the attribute unchanged 
            
                 No longer doing this, since just need to set height and width
                 And don't want to reset the name (filename) -->
            <!--
            <xf:action xxf:iterate="$mediaFile/@*">
                <xxf:variable name="attribute" select="."/>
                <xxf:variable name="attributeName" select="$attribute/name()"/>

                <xxf:variable name="fileAttribute" select="$file/@*[name()=$attributeName]"/>
                <xxf:variable name="fileMetaData" select="$file//*[name()=$attributeName]"/>

                <xf:setvalue ref="$attribute"
                    value="if (exists($fileAttribute)) then $fileAttribute else if (exists($fileMetaData)) then $fileMetaData else ."/>
            </xf:action>
            -->

            <!-- Set the height and width attributes of the mediaFile
                 These areelements in the image-metadata -->
            <xf:setvalue ref="$mediaFile/@height" value="$file//height"/>
            <xf:setvalue ref="$mediaFile/@width" value="$file//width"/>

        </xf:action>
    </xf:action>


    <!-- ========= Application Image Maps ==================== 
         These actions are for managing image maps
         Additional actions for handling image maps in compositions are in the imageMapModel
         ===================================================== -->

    <xf:instance id="imageMapFileList-instance">
        <imageMapFileList xmlns=""/>
    </xf:instance>

    <xf:instance id="storedImageMapFileList-instance">
        <imageMapFileList/>
    </xf:instance>

    <xf:instance id="shippedImageMapFileList-instance">
        <imageMapFileList/>
    </xf:instance>

    <!-- Instance to hold image map for storage/load -->
    <xf:instance id="application-imageMap-instance">
        <svg:svg/>
    </xf:instance>

    <!-- Query to get stored image map files -->
    <xf:instance id="storedImageMapListXQuery-instance"
        src="oxf:/apps/ehr/xquery/storedImageMapListXQuery.xml"/>



    <!-- Application defined action to initialize the list of shipped images maps.
         Used in create-application.
         Gets the shippedImageMapFileList in shippedImageMapFileList-instance -->
    <xf:action ev:event="initialize-shippedImageMapFileList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/imageMaps')"/>
            <xxf:context name="staticResourcePattern" select="'*.svg'"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedImageMapFileList-instance')"/>
            <xxf:context name="fileTemplate"
                select="xxf:instance('applicationControl-instance')/importShippedResources/imageMapFile"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>
    </xf:action>


    <!-- Application defined action to load an image map file from disk.
         The imageMap fileName is passed as a parameter 
         This is for shipped image maps, so the fileName is relative to the shipped image map location
         Locate imageMap on disk and load into application-imageMap-instance
         -->
    <xf:action ev:event="load-imageMap-from-disk">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="fileName" select="event('fileName')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Filename must not be blank -->
        <xf:action if="$fileName !=''">
            <!-- Set the staticResourceLocation -->
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/imageMaps/',$fileName)"/>

            <!-- Load the image map from disk - must be XML -->
            <xf:dispatch name="dal-readStaticResourceAsXML" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource" select="xxf:instance('application-imageMap-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>
        </xf:action>

    </xf:action>


    <!-- Application defined action to reload shipped image maps from disk.
         Uses the id for each image map which was set when originally loaded from disk (includes the full filename with extension) -->
    <xf:action ev:event="reload-shippedImageMaps">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('control-instance')/managedApplication/applicationIRI"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Get the list of media shipped for this application -->
        <xf:dispatch name="initialize-shippedImageMapFileList" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
        </xf:dispatch>

        <!-- Iterate through the image map files, load and save to the database -->
        <xf:action xxf:iterate="xxf:instance('shippedImageMapFileList-instance')/imageMapFile">
            <xxf:variable name="imageMapFile" select="."/>
            <xxf:variable name="fileName" select="$imageMapFile/@name"/>

            <!-- Load the image map from disk 
                 The image map is loaded to application-imageMap-instance -->
            <xf:dispatch name="load-imageMap-from-disk" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="fileName" select="$fileName"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- If the imageMap was loaded -->
            <xf:action if="xxf:instance('applicationControl-instance')/status=''">
                <xf:action if="xxf:instance('application-imageMap-instance')/name()='svg'">

                    <!-- Transfer contents of the SVG -->
                    <xf:dispatch name="transfer-imageMap" target="application-model">
                        <xxf:context name="imageMap-instance"
                            select="xxf:instance('application-imageMap-instance')"/>
                        <xxf:context name="imageMapFile" select="$imageMapFile"/>
                    </xf:dispatch>

                    <!-- Save the image map file -->
                    <xf:dispatch name="save-imageMapFile" target="application-model">
                        <xxf:context name="applicationId" select="$applicationId"/>
                        <xxf:context name="imageMapFile" select="$imageMapFile"/>
                    </xf:dispatch>
                </xf:action>
            </xf:action>

        </xf:action>

    </xf:action>



    <!-- Application defined action to get list of image map files for a set of entries.
         The entries are passed as entryIRIList
         The list of image map files is formed in imageMapFileList-instance.
         If no image map exists in the xmlstore, then an empty file is set up using the template in importShippedResources -->
    <xf:action ev:event="get-imageMapFileList">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="entryIRIList" select="event('entryIRIList')"/>

        <!-- Clear the imageMapFileList-instance -->
        <xf:delete nodeset="xxf:instance('imageMapFileList-instance')/*"/>

        <!-- The image map file and image map templates -->
        <xxf:variable name="imageMapFileTemplate"
            select="xxf:instance('applicationControl-instance')/importShippedResources/imageMapFile"/>
        <xxf:variable name="imageMapTemplate"
            select="xxf:instance('applicationControl-instance')/storedResources/svg:svg"/>

        <!-- Get the stored image maps -->
        <xxf:variable name="imageMapStorageLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/imageMaps')"/>
        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$imageMapStorageLocation"/>
            <xxf:context name="query" select="xxf:instance('storedImageMapListXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('storedImageMapFileList-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Iterate through the entryIRIList -->
        <xf:action xxf:iterate="$entryIRIList">
            <xxf:variable name="entryIRI" select="."/>
            <xxf:variable name="entryId" select="substring-after($entryIRI,'#ISO-13606:Entry:')"/>

            <!-- Stored image map file -->
            <xxf:variable name="storedImageMapFile"
                select="xxf:instance('storedImageMapFileList-instance')/imageMapFile[svg:svg/@id=$entryId]"/>

            <!-- If there is a stored image map file -->
            <xf:action if="exists($storedImageMapFile)">
                <xf:insert context="xxf:instance('imageMapFileList-instance')" nodeset="*"
                    origin="$storedImageMapFile" at="last()" position="after"/>
            </xf:action>

            <!-- If there is no stored image map file -->
            <xf:action if="not(exists($storedImageMapFile))">
                <xf:insert context="xxf:instance('imageMapFileList-instance')" nodeset="*"
                    origin="$imageMapFileTemplate" at="last()" position="after"/>
                <xxf:variable name="imageMapFile"
                    select="xxf:instance('imageMapFileList-instance')/*[last()]"/>

                <xf:insert context="$imageMapFile" origin="$imageMapTemplate"/>
                <xf:setvalue ref="$imageMapFile/svg:svg/@id" value="$entryId"/>
            </xf:action>
        </xf:action>

    </xf:action>



    <!-- Application defined action to transfer an image map from an uploaded instance
         To an image map file that is in the imageMapList -->
    <xf:action ev:event="transfer-imageMap">
        <xxf:variable name="imageMap-instance" select="event('imageMap-instance')"/>
        <xxf:variable name="imageMapFile" select="event('imageMapFile')"/>

        <!-- Transfer the SVG contents -->
        <xf:delete nodeset="$imageMapFile/*"/>
        <xf:insert context="$imageMapFile" origin="$imageMap-instance"/>

    </xf:action>


    <!-- Application defined action to clear an image map file
         This is done if the @path is cleared by the user -->
    <xf:action ev:event="clear-imageMapFile">
        <xxf:variable name="imageMapFile" select="event('imageMapFile')"/>
        <xxf:variable name="imageMapId" select="event('imageMapId')"/>

        <!-- Reset the error message -->
        <xf:setvalue ref="$imageMapFile/@errorMessage" value="''"/>

        <!-- Remove the SVG image map -->
        <xf:delete nodeset="$imageMapFile/*"/>

        <!--Reset with the image map template -->
        <xxf:variable name="imageMapTemplate"
            select="xxf:instance('applicationControl-instance')/storedResources/svg:svg"/>
        <xf:insert context="$imageMapFile" origin="$imageMapTemplate"/>
        <xf:setvalue ref="$imageMapFile/svg:svg/@id" value="$imageMapId"/>

    </xf:action>


    <!-- Application defined action to save the image map files in imageMapFileList
         Iterate through the list and save each file
         -->
    <xf:action ev:event="save-imageMapFileList">
        <xxf:variable name="applicationId" select="event('applicationId')"/>

        <!-- Iterate through the imageMapFileList -->
        <xf:action xxf:iterate="xxf:instance('imageMapFileList-instance')/*">
            <xxf:variable name="imageMapFile" select="."/>

            <xf:dispatch name="save-imageMapFile" target="application-model">
                <xxf:context name="applicationId" select="$applicationId"/>
                <xxf:context name="imageMapFile" select="$imageMapFile"/>
            </xf:dispatch>

        </xf:action>

    </xf:action>


    <!-- Application defined action to save an image map.
         The image map file is passed as a parameter
          -->
    <xf:action ev:event="save-imageMapFile">
        <xxf:variable name="applicationId" select="event('applicationId')"/>
        <xxf:variable name="imageMapFile" select="event('imageMapFile')"/>

        <xxf:variable name="entryId" select="$imageMapFile/svg:svg/@id"/>

        <!-- Only save if the entryId is set -->
        <xf:action if="not($entryId = '')">
            <xxf:variable name="storageLocation"
                select="concat('/xmlstore/applications/',$applicationId,'/systemConfiguration/imageMaps/',$entryId)"/>

            <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$storageLocation"/>
                <xxf:context name="resource" select="$imageMapFile"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Set errorMessage if no id in the image map -->
        <xf:action if="$entryId = ''">
            <xf:setvalue ref="$imageMapFile/@errorMessage"
                value="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageImageMaps/errorMessageList/errorMessage[@type='badImageMapId']/@displayName"
            />
        </xf:action>


        <!-- Problem saving image map file -->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:setvalue ref="$imageMapFile/@errorMessage"
                value="xxf:instance('view-parameters-instance')/staticParameters/cityEHRAdmin/manageImageMaps/errorMessageList/errorMessage[@type='failedSaveImageMapFile']/@displayName"
            />
        </xf:action>

    </xf:action>



    <!-- ========= Information models ======================== 
         ===================================================== -->

    <!-- Instances for lists of models shipped with the installation -->
    <xf:instance id="shippedInformationModelList-instance">
        <directory/>
    </xf:instance>
    <xf:instance id="defaultInformationModelList-instance">
        <directory/>
    </xf:instance>

    <!-- Instances for information models in OWL/XML - informationModel, storedInformationModel -->
    <xf:instance id="informationModel-instance">
        <owl:Ontology/>
    </xf:instance>
    <xf:instance id="storedInformationModel-instance">
        <owl:Ontology/>
    </xf:instance>


    <!-- Instance for informationModel loaded from disk (XML) -->
    <xf:instance id="uploadedInformationModel-instance">
        <model/>
    </xf:instance>

    <!-- Instance for dictionary generated from  informationModel -->
    <xf:instance id="modelDictionary-instance">
        <dictionary/>
    </xf:instance>

    <!-- Instance for composition set generated from  informationModel -->
    <xf:instance id="compositionSet-instance">
        <compositionSet/>
    </xf:instance>

    <!-- Instance for composition -->
    <xf:instance id="composition-instance">
        <ClinicalDocument xmlns="urn:hl7-org:v3"/>
    </xf:instance>

    <!-- Instance for results of checking expressions -->
    <xf:instance id="checkExpressions-instance">
        <checkExpressions/>
    </xf:instance>


    <!-- Application defined action to get the (ordered) list of default information models.
         These are shipped for applications with the cityEHR installation.
         
         The application may have a common model specified, which should have a specialty model and zero or more class models.
          
         This action requires the application parameters that have been loaded to working-application-parameters-instance
         
         The models need to be imported in a specific order:
            1) The common specialty model and any class models for the common model (loaded in any order)
            2) All other models, which are merged with the common specialy model or relevant class model for the common specialty
            
         To ensure the correct order for import, sort the shippedInformationModelList to create defaultInformationModelList.
         -->
    <xf:action ev:event="get-defaultInformationModelList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="commonModelIRI" select="event('commonModelIRI')"/>
        <xxf:variable name="release" select="event('release')"/>
        <xxf:variable name="status" select="event('status')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the common model from the working-application-parameters -->
        <xxf:variable name="commonModelName"
            select="substring-after($commonModelIRI,'#ISO-13606:Folder:')"/>

        <!-- Clear out the information model lists -->
        <xf:delete nodeset="xxf:instance('shippedInformationModelList-instance')/*"/>
        <xf:delete nodeset="xxf:instance('defaultInformationModelList-instance')/*"/>

        <!-- Use .xml or .ods models - depends om whether release 1 or 2 -->
        <xxf:variable name="modelPattern" select="if ($release='1') then '*.xml' else '*.ods'"/>

        <!-- Get the list of information models shipped with the cityEHR installation.
             These are in .xml or .ods format spreadsheets and will be read as XML in cityEHR database format-->
        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/informationModel')"/>
            <xxf:context name="staticResourcePattern" select="$modelPattern"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedInformationModelList-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Iterate through the models to check specialty.
             Form informationModelList with common models listed first -->
        <xf:action xxf:iterate="xxf:instance('shippedInformationModelList-instance')/file">
            <xxf:variable name="file" select="."/>
            <xxf:variable name="fileName" select="$file/@name"/>
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/informationModel/',$fileName)"/>

            <xf:dispatch name="dal-readStaticResourceAsXML" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource"
                    select="xxf:instance('uploadedInformationModel-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- resourceRoot should be Workbook or database -->
            <xxf:variable name="resourceRoot"
                select="xxf:instance('uploadedInformationModel-instance')/name()"/>

            <!-- If the model was loaded successfully from disk.
                 Check whether this is from the common model specialty.
                 If it is, then insert at the start of informationModelList, if not then insert at the end. -->
            <xf:action if="xxf:instance('applicationControl-instance')/status = ''">
                <!-- The specialtyName is on the Configuration sheet.
                     Could be a Worksheet (release 1) or table (release 2) -->
                <xxf:variable name="specialtyName"
                    select="if ($resourceRoot='database') then normalize-space(xxf:instance('uploadedInformationModel-instance')//table[@id='Configuration']/record[field[1]='SpecialtyId']/field[2])
                    else if ($resourceRoot='Workbook') then normalize-space(xxf:instance('uploadedInformationModel-instance')//ss:Worksheet[@ss:Name='Configuration']/office2003Spreadsheet:Table/office2003Spreadsheet:Row[office2003Spreadsheet:Cell[1]/office2003Spreadsheet:Data='Specialty']/office2003Spreadsheet:Cell[2]/office2003Spreadsheet:Data)
                    else '' "/>

                <!-- If this is from the common model specialty, then insert at the start of defaultInformationModelList.
                     Note that the commonModelName may be blank, but the specialtyName must not be blank -->
                <xf:action if="$specialtyName != '' and $specialtyName = $commonModelName">
                    <xf:insert context="xxf:instance('defaultInformationModelList-instance')"
                        nodeset="*" origin="$file" at="1" position="before"/>
                </xf:action>
                <!-- If this is not from the common model specialty, then insert at the end of defaultInformationModelList.
                     Note that the specialtyName must not be blank -->
                <xf:action if="$specialtyName != '' and $specialtyName != $commonModelName">
                    <xf:insert context="xxf:instance('defaultInformationModelList-instance')"
                        nodeset="*" origin="$file" at="last()" position="after"/>
                </xf:action>
            </xf:action>
        </xf:action>
    </xf:action>


    <!-- Application defined action to load an information model from disk.
         Loads an information model from cityEHR resources on disk, given the applicationIRI and fileName.
         The model is loaded from a spreadsheet to uploadedInformationModel-instance.
         Then converted to OWL/XML and returned in informationModel-instance.
         Sets status to an error code if the file cannot be read, it cannot be converted to OWL/XML or the application in the model does not match.        
         -->

    <xf:action ev:event="load-informationModel">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="fileName" select="event('fileName')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Filename must not be blank -->
        <xf:action if="$fileName !=''">
            <!-- Set the staticResourceLocation -->
            <xxf:variable name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/informationModel/',$fileName)"/>

            <!-- Load the model from disk -->
            <xf:dispatch name="dal-readStaticResourceAsXML" target="databaseAccessLayer-model">
                <xxf:context name="staticResourceLocation" select="$staticResourceLocation"/>
                <xxf:context name="resource"
                    select="xxf:instance('uploadedInformationModel-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- If the model was loaded successfully-->
            <xf:action if="xxf:instance('applicationControl-instance')/status = ''">
                <!-- resourceRoot should be Workbook or database -->
                <xxf:variable name="resourceRoot"
                    select="xxf:instance('uploadedInformationModel-instance')/name()"/>

                <!-- For release 1, set up pipeline to convert MS XML 2003 to OWL/XML
                     After 2023-03, release 2 set up pipeline to convert cityEHR database format to OWL/XML-->

                <xxf:variable name="xsltPipeline"
                    select="if ($resourceRoot='Workbook') then 'convertSpreadsheet2OWL.xpl' else 'convertDatabase2OWL.xpl'"/>

                <!-- Set the informationModel-instance by invoking the pipeline -->
                <!--
                <xxf:variable name="xsltPipeline"
                    select="if ($resourceRoot='Workbook') then concat(xxf:instance('view-parameters-instance')/appPath,'/pipelines/convertSpreadsheet2OWL.xpl') else concat(xxf:instance('view-parameters-instance')/appPath,'/pipelines/convertDatabase2OWL.xpl')"/>

                <xf:insert nodeset="xxf:instance('informationModel-instance')"
                    origin="xxf:call-xpl($xsltPipeline, 'instance', xxf:instance('uploadedInformationModel-instance'), 'data')"/>
                    -->
                <xf:dispatch name="invoke-pipeline" target="pageNavigation-model">
                    <xxf:context name="pipeline" select="$xsltPipeline"/>
                    <xxf:context name="input-instance"
                        select="xxf:instance('uploadedInformationModel-instance')"/>
                    <xxf:context name="return-instance"
                        select="xxf:instance('informationModel-instance')"/>
                </xf:dispatch>

                <!-- Set importedFromFile annotation in the ontology -->
                <xf:setvalue
                    ref="xxf:instance('informationModel-instance')/owl:Annotation[owl:AnnotationProperty/@abbreviatedIRI='rdfs:importedFromFile']/owl:Literal"
                    value="$staticResourceLocation"/>
            </xf:action>
        </xf:action>

        <!-- Set status if the OWL/XML ontology is bad, for whatever reason
             Could be fileName blank, model not found on disk, conversion to OWL/XML failed -->
        <xxf:variable name="modelApplicationIRI"
            select="xxf:instance('informationModel-instance')/owl:ClassAssertion[owl:Class/@IRI='#ISO-13606:EHR_Extract']/owl:NamedIndividual[1]/@IRI"/>
        <xf:setvalue ref="xxf:instance('applicationControl-instance')/status"
            value="if ($modelApplicationIRI = $applicationIRI) then '' else 'failed-to-load-model-from-disk' "/>

        <!-- Set the return status -->
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>


    <!-- Application defined action to initialize parameters before inporting shipped models.
         Used in create-application and import-shippedResources.
         Scope is full, informationModels or applicationResources (default is full)
         Requires working-application-parameters to be loaded for the application
         Sets up importModelParameters ready for the import of each model.
         Gets the defaultInformationModelList, languagePackList, directoryList, mediaList -->
    <xf:action ev:event="initialize-importShippedResources">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="scope"
            select="if (exists(event('scope'))) then event('scope') else 'full'"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set parameters to be used in the import-informationModel sub process -->
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationId"
            value="$applicationId"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"
            value="$applicationIRI"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeExistingModel"
            value="false()"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@rebuildDirectories"
            value="true()"/>

        <!-- Set the baseLanguageCode from the working-application-parameters -->
        <xxf:variable name="baseLanguageCode"
            select="xxf:instance('working-application-parameters-instance')/application/iso-13606:EHR_Extract/@baseLanguageCode"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/baseLanguageCode"
            value="lower-case($baseLanguageCode)"/>

        <!-- Set the common model from the working-application-parameters -->
        <xxf:variable name="commonModelIRI"
            select="xxf:instance('working-application-parameters-instance')/application/iso-13606:EHR_Extract/@commonModel"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelIRI"
            value="$commonModelIRI"/>
        <xxf:variable name="commonModelId" select="replace(substring($commonModelIRI,2),':','-')"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelId"
            value="$commonModelId"/>

        <!-- If there is a common model, then merge all imported models -->
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeCommonModel"
            value="if ($commonModelIRI!='') then true() else false()"/>

        <!-- Get the release - 1 or 2.
             Release 1 uses xml spreadsheet models (saved/exported from .ods)
             Release 2 uses ods spreadsheet models directly -->
        <xxf:variable name="release"
            select="if (exists(xxf:instance('working-application-parameters-instance')/application/@release)) then xxf:instance('working-application-parameters-instance')/application/@release else xxf:instance('view-parameters-instance')/versionNumber/@release"/>

        <!-- Clear the lists of shipped resources -->
        <xf:dispatch name="clear-shippedResourceLists" target="application-model"/>

        <!-- Get the list of default information models shipped with the application.
             Only if scope is full or informationModels
             These are placed in defaultInformationModelList-instance -->
        <xf:action if="$scope = ('full','informationModels') ">
            <xf:dispatch name="get-defaultInformationModelList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="commonModelIRI" select="$commonModelIRI"/>
                <xxf:context name="release" select="$release"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Only import the other resources if the scope is 'full' (the default) or applicationResources -->
        <xf:action if="$scope = ('full','applicationResources') ">
            <!-- Get the lists of language packs, directories and media -->
            <xf:dispatch name="initialize-shippedLanguagePackList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>
            <xf:dispatch name="initialize-shippedDirectoryList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>
            <xf:dispatch name="initialize-shippedMediaList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>

            <!-- Get list of imageMaps and letter templates -->
            <xf:dispatch name="initialize-shippedImageMapFileList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>
            <xf:dispatch name="initialize-shippedLetterTemplateList" target="application-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>

            <!-- Load the application stylesheets - this from manageParametersModel
                 Imported stylesheets are added to this list -->
            <xf:dispatch name="load-application-stylesheets" target="manageParameters-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- Get the list of stylesheets - this from manageParametersModel -->
            <xf:dispatch name="initialize-shippedStylesheetList" target="manageParameters-model">
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>

        </xf:action>
    </xf:action>


    <!-- Application defined action to load default information models from disk.
         Plus other resources, depending on the setting of the scope parameter
         
         Scope is full, informationModels or applicationResources (default is full)
  
         The default models are shipped with the cityEHR installation.
         The application may have a common model specified, which should have a specialty model and zero or more class models.
         
         The models need to be imported in a specific order:
            1) The common specialty model and any class models for the common model (loaded in any order)
            2) All other models, which are merged with the common specialy model or relevant class model for the common specialty
            
         To ensure the correct order for import, sort the shippedInformationModelList to create defaultInformationModelList.
         
         Then run the process to import-shippedResources
         -->
    <xf:action ev:event="import-shippedResources">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="completionActionModel"
            select="if (exists(event('completionActionModel'))) then event('completionActionModel') else ''"/>
        <xxf:variable name="completionActionName"
            select="if (exists(event('completionActionName'))) then event('completionActionName') else ''"/>
        <xxf:variable name="scope"
            select="if (exists(event('scope'))) then event('scope') else 'full'"/>

        <!-- Initialize parameters ready to import shipped resources.
             If no scope is passed, then default is full (i.e. import all shipped resources)
             Scope is only needed here, since all resource lists are set here 
              - if they are left empty then nothing is imported -->
        <xf:dispatch name="initialize-importShippedResources" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="scope" select="$scope"/>
        </xf:dispatch>

        <!-- Run the process to import models from the file system, using:
                defaultInformationModelList
                shippedLanguagePackList
                shippedDirectoryList
                shippedMediaList
                shippedImageMapFileList
                shippedLetterTemplateList
                shippedStylesheetList (defined in manageParametersModel)
        -->
        <xf:variable name="contextSet"
            select="xxf:instance('defaultInformationModelList-instance')/file | xxf:instance('shippedLanguagePackList-instance')/languagePackFile | xxf:instance('shippedDirectoryList-instance')/directoryFile | xxf:instance('shippedMediaList-instance')/mediaFile | xxf:instance('shippedImageMapFileList-instance')/imageMapFile | xxf:instance('shippedLetterTemplateList-instance')/letterTemplateFile | xxf:instance('shippedStylesheetList-instance')/stylesheetFile"/>
        <xf:dispatch name="run-process" target="process-model">
            <xxf:context name="processName" select="'import-shippedResources'"/>
            <xxf:context name="contextSet" select="$contextSet"/>
            <xxf:context name="completionActionModel" select="$completionActionModel"/>
            <xxf:context name="completionActionName" select="$completionActionName"/>
        </xf:dispatch>

    </xf:action>


    <!-- === import-shippedResources
         This process is defined in view-parameters.
         Invoked from the action import-shippedResources
         Parameters for the process are held in xxf:instance('applicationControl-instance')/importModelParameters
         Invoked with a contextSet which is a list of files holding the information models, directories and media to be imported.
         
         For each file in the contextSet:
            Invoke importShippedResources-importModel to:
                Read the file from disk
                Convert to OWL/XML
                Invoke the sub-process import-informationModel
                
         For each directoryFile in the contextSet:
            Invoke importShippedResources-importDirectory to import the directory   

         For each mediaFile in the contextSet:
            Invoke importShippedResources-importMedia to import the media  
            
         For each imageMapFile in the contextSet:
            Invoke importShippedResources-importImageMaps to import the image map 
 
         For each letterTemplateFile in the contextSet:
            Invoke importShippedResources-importLetterTemplates to import the letter template 
            
         For each languagePackFile in the contextSet:
            Invoke importShippedResources-importLanguagePacks to import the language pack 

         For each stylesheetFile in the contextSet:
            Invoke importShippedResources-importStylesheets to import the stylesheet 
            
         
         Invoke resetSpecialtyList
        -->

    <!-- Application defined action to import an information model from the speficied file.
         An action in the importShippedResources process.
         The file is passed as the context to this action.
         The model is read from the file to informationModel-instance
         So that the import-informationModel sub-process is ready to run -->
    <xf:action ev:event="importShippedResources-importModel">
        <xxf:variable name="file" select="event('context')"/>

        <xxf:variable name="fileName" select="$file/@name"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <!-- Load the information model -->
        <xf:dispatch name="load-informationModel" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Abort the import process if the model was not loaded successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>

    <!-- Application defined action to import the (entry) directories shipped with an application.
         An action in the importShippedResources process.
         Is invoked with the context set for each file in the directories folder of the application. -->
    <xf:action ev:event="importShippedResources-importDirectory">
        <xxf:variable name="directoryFile" select="event('context')"/>

        <xxf:variable name="fileName" select="$directoryFile/@name"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <!-- Load the directory from disk 
             The directory is loaded to workingDirectory-instance -->
        <xf:dispatch name="load-directory-from-disk" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- If the directory was loaded -->
        <xf:action if="xxf:instance('applicationControl-instance')/status=''">
            <xxf:variable name="directory"
                select="xxf:instance('applicationControl-instance')/directoryParameters/directory"/>

            <!-- Set directory parameters from the workingDirectory-instance -->
            <xf:setvalue ref="$directory/@type"
                value="xxf:instance('workingDirectory-instance')/@cityEHR:type"/>
            <xf:setvalue ref="$directory/@root"
                value="xxf:instance('workingDirectory-instance')/@cityEHR:root"/>
            <xf:setvalue ref="$directory/@key"
                value="xxf:instance('workingDirectory-instance')/@cityEHR:key"/>
            <xf:setvalue ref="$directory/@specialtyIRI"
                value="xxf:instance('workingDirectory-instance')/@cityEHR:specialtyIRI"/>
            <xf:setvalue ref="$directory/@commonModelIRI"
                value="xxf:instance('applicationControl-instance')/importModelParameters/commonModelIRI"/>

            <xf:dispatch name="save-directory" target="application-model">
                <xxf:context name="directory" select="$directory"/>
                <xxf:context name="directory-instance"
                    select="xxf:instance('workingDirectory-instance')"/>
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

        </xf:action>

        <!-- Abort the import process if the directory was not loaded successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>

    <!-- Application defined action to import the media shipped with an application.
         An action in the importShippedResources process.
         The mediaFile passed as a parameter will be saved to the database, once its base64 content has been loaded -->
    <xf:action ev:event="importShippedResources-importMedia">
        <xxf:variable name="mediaFile" select="event('context')"/>

        <xxf:variable name="fileName" select="$mediaFile/@name"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <!-- Load the media from disk 
             The media is loaded to application-media-instance -->
        <xf:dispatch name="load-media-from-disk" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- If the media was loaded -->
        <xf:action if="xxf:instance('applicationControl-instance')/status=''">
            <xf:dispatch name="save-media" target="application-model">
                <xxf:context name="mediaFile" select="$mediaFile"/>
                <xxf:context name="media-instance"
                    select="xxf:instance('application-media-instance')"/>
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Abort the import process if the media file was not loaded successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>

    <!-- Application defined action to import the image maps shipped with an application.
         An action in the importShippedResources process.. -->
    <xf:action ev:event="importShippedResources-importImageMaps">
        <xxf:variable name="imageMapFile" select="event('context')"/>

        <xxf:variable name="fileName" select="$imageMapFile/@name"/>

        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationIRI" select="$importModelParameters/applicationIRI"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <!-- Load the image map from disk 
             The image map is loaded to application-imageMap-instance -->
        <xf:dispatch name="load-imageMap-from-disk" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- If the imageMap was loaded -->
        <xf:action if="xxf:instance('applicationControl-instance')/status=''">
            <xf:action if="xxf:instance('application-imageMap-instance')/name()='svg'">

                <!-- Transfer contents of the SVG -->
                <xf:dispatch name="transfer-imageMap" target="application-model">
                    <xxf:context name="imageMap-instance"
                        select="xxf:instance('application-imageMap-instance')"/>
                    <xxf:context name="imageMapFile" select="$imageMapFile"/>
                </xf:dispatch>

                <!-- Save the imageMapFile -->
                <xf:dispatch name="save-imageMapFile" target="application-model">
                    <xxf:context name="applicationId" select="$applicationId"/>
                    <xxf:context name="imageMapFile" select="$imageMapFile"/>
                </xf:dispatch>
            </xf:action>
        </xf:action>

        <!-- Abort the import process if the image map was not loaded successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>

    <!-- Application defined action to import the letter templates shipped with an application.
         An action in the importShippedResources process.
         The letterTemplateFile is the binary content of the letter template (.docx or .odt) loaded from disk.
    
         Need to create the letterTemplate, insert the binary content, extract the variable and save to the xmlstore 
    
         The binary files are named with the displayName of the template -->
    <xf:action ev:event="importShippedResources-importLetterTemplates">
        <xxf:variable name="letterTemplateFile" select="event('context')"/>

        <xxf:variable name="fileName" select="$letterTemplateFile/@name"/>
        <xxf:variable name="applicationIRI"
            select="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$fileName"/>
        </xf:dispatch>

        <!-- Load the letter template binary from disk 
             The letter template binary is loaded to application-letterTemplateBinary-instance
             This is the binary instance -->
        <xf:dispatch name="load-letterTemplateBinary-from-disk" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="fileName" select="$fileName"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- If the letter template binary was loaded.
             Create a letterTemplate, with the binary and a list of the variables 
             This sets the status -->
        <xf:action if="xxf:instance('applicationControl-instance')/status=''">

            <!-- Create the letterTemplateFile in application-letterTemplateFile-instance.
                 Set the content type to the default (application/*) -->
            <xf:dispatch name="create-letterTemplateFile" target="application-model">
                <xxf:context name="letterTemplateFilename" select="$fileName"/>
                <xxf:context name="letterTemplateContentType"
                    select="xxf:instance('view-parameters-instance')/sourceType/@default"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- displayName is fileName, without extension
                  value is displayName, without spaces -->
            <xxf:variable name="fileNameDisplayName" select="substring-before($fileName,'.')"/>
            <xxf:variable name="fileNameValue"
                select="translate(normalize-space($fileNameDisplayName),'# &#09;&#10;','')"/>

            <!-- Create the letter template in application-letterTemplate-instance -->
            <xf:dispatch name="create-letterTemplate" target="application-model">
                <xxf:context name="value" select="$fileNameValue"/>
                <xxf:context name="displayName" select="$fileNameDisplayName"/>
                <xxf:context name="letterTemplateFile"
                    select="xxf:instance('application-letterTemplateFile-instance')"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

            <!-- Set the letterTemplate binary content -->
            <xf:dispatch name="set-letterTemplateBinaryContent" target="application-model">
                <xxf:context name="letterTemplate"
                    select="xxf:instance('application-letterTemplate-instance')"/>
                <xxf:context name="letterTemplateBinaryContent"
                    select="xxf:instance('application-letterTemplateBinary-instance')"/>
            </xf:dispatch>

            <!-- Save the letter template -->
            <xf:dispatch name="save-letterTemplate" target="application-model">
                <xxf:context name="letterTemplate"
                    select="xxf:instance('application-letterTemplate-instance')"/>
                <xxf:context name="applicationIRI" select="$applicationIRI"/>
            </xf:dispatch>

        </xf:action>

        <!-- Abort the import process if the letter template file was not loaded or saved successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>


    <!-- Application defined action to import the language packs shipped with an application.
         An action in the importShippedResources process.. -->
    <xf:action ev:event="importShippedResources-importLanguagePacks"> </xf:action>


    <!-- Application defined action to import the stylesheets shipped with an application.
         An action in the importShippedResources process.
         Add the stylesheet to the applicationStylesheetList-instance -->
    <xf:action ev:event="importShippedResources-importStylesheets">
        <xxf:variable name="stylesheetFile" select="event('context')"/>
        <xxf:variable name="stylesheetName" select="$stylesheetFile/@name"/>

        <!-- Remove existing stylesheet of the same name -->
        <xf:delete
            nodeset="xxf:instance('applicationStylesheetList-instance')/stylesheetFile[@name=$stylesheetName]"/>

        <!-- Set the default stylsheet as selected.
             On;y if there isn't another styelsheet set as selected in the list
             Since there can nly be one default, this set it as selected so long as the user hasn't 
             imported and set a different stylesheet -->
        <xxf:variable name="defaultApplicationStylesheet"
            select="xxf:instance('application-parameters-instance')/application/applicationStylesheet/@value"/>
        <xf:action
            if="not(xxf:instance('applicationStylesheetList-instance')/stylesheetFile/@selected='true')
            and $stylesheetName = $defaultApplicationStylesheet">

            <xf:setvalue ref="$stylesheetFile/@selected" value="'true'"/>
        </xf:action>

        <!-- Add the stylesheet -->
        <xf:insert context="xxf:instance('applicationStylesheetList-instance')" nodeset="*"
            origin="$stylesheetFile" at="last()" position="after"/>

    </xf:action>


    <!-- Application defined action to reset the specialtyList after models have been imported.
         An action in the importShippedResources process.. -->
    <xf:action ev:event="importShippedResources-resetApplicationResources">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>

        <!-- Reset the specialtyList -->
        <xf:dispatch name="get-specialtyList" target="application-model">
            <xxf:context name="applicationId" select="$applicationId"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Save the applicationStylesheetList
              /db/ehr/xmlstore/applications/ISO-13606-EHR_Extract-cityEHR/systemConfiguration/application-stylesheets-->
        <xf:dispatch name="save-application-stylesheets" target="manageParameters-model">
            <xxf:context name="applicationId" select="$applicationId"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>
    </xf:action>



    <!-- === import-informationModel
         This process is defined in view-parameters.
         It is invoked directly in the import-informationModel action 
         or as a sub-process of import-shippedResources or create-application 
         Parameters for the process are held in xxf:instance('applicationControl-instance')/importModelParameters
         In importModelParameters, applicationIRI. applicationId and baseLanguageCode (the language of the application) must already be set
         The OWL/XML model to be imported must be set in informationModel-instance
         
         The following actions are invoked:
            importInformationModel-verify
            importInformationModel-merge
            importInformationModel-save
            importInformationModel-generateDictionary
            importInformationModel-createCompositions
            importInformationModel-rebuildDirectories
            importInformationModel-updateLanguagePacks
            importInformationModel-clearFormCache
        -->


    <!-- Application defined action to import the information model (OWL/XML) passed as informationModel-instance.
         Invoked from cityEHRAdmin.
         Sets up parameters and then invokes the import-InformationModel process.
            This action should only be invoked after the informationModel-instance has been checked for application, specialty, model and language
            The checks are perfromed in cityEHRAdmin by X
            (although these checks are also made again in importInformationModel-verify
         Or if checkExpressions is set to 'true' then invokes the check-expressions process (does not import) -->
    <xf:action ev:event="import-informationModel">
        <xxf:variable name="informationModel-instance" select="event('informationModel-instance')"/>
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="baseLanguageCode" select="event('baseLanguageCode')"/>
        <xxf:variable name="commonModelIRI" select="event('commonModelIRI')"/>
        <xxf:variable name="mergeExistingModel" select="event('mergeExistingModel')"/>
        <xxf:variable name="mergeCommonModel" select="event('mergeCommonModel')"/>
        <xxf:variable name="rebuildDirectories" select="event('rebuildDirectories')"/>
        <xxf:variable name="checkExpressions" select="event('checkExpressions')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>
        <xxf:variable name="commonModelId" select="replace(substring($commonModelIRI,2),':','-')"/>

        <!-- Set the informationModel-instance -->
        <xf:insert nodeset="xxf:instance('informationModel-instance')"
            origin="$informationModel-instance"/>

        <!-- Set parameters to be used in the import-informationModel process -->
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"
            value="$applicationIRI"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationId"
            value="$applicationId"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/baseLanguageCode"
            value="lower-case($baseLanguageCode)"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelIRI"
            value="$commonModelIRI"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelId"
            value="$commonModelId"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeExistingModel"
            value="$mergeExistingModel"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeCommonModel"
            value="$mergeCommonModel"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/@rebuildDirectories"
            value="$rebuildDirectories"/>

        <!-- Run the process to import the model, if checkExpressions is false
             import-informationModelComplete is defined in the main-model of cityEHRAdmin -->
        <xf:action if="$checkExpressions != true()">
            <xf:dispatch name="run-process" target="process-model">
                <xxf:context name="processName" select="'import-informationModel'"/>
                <xxf:context name="contextSet" select="()"/>
                <xxf:context name="completionActionModel" select="'main-model'"/>
                <xxf:context name="completionActionName" select="'import-informationModelComplete'"
                />
            </xf:dispatch>
        </xf:action>

        <!-- Run the process to check expressions, if checkExpressions is true -->
        <xf:action if="$checkExpressions = true()">
            <xf:dispatch name="run-process" target="process-model">
                <xxf:context name="processName" select="'check-expressions'"/>
                <xxf:context name="contextSet" select="()"/>
                <xxf:context name="completionActionModel" select="''"/>
                <xxf:context name="completionActionName" select="''"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to verify the information model loaded in informationModel-instance.
         An action in the import-InformationModel process.
         If there is a problem with the model, then abort the import process
         -->
    <xf:action ev:event="importInformationModel-verify">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>

        <!-- Get application from the ontology - must match the import process -->
        <xxf:variable name="applicationIRI"
            select="xxf:instance('informationModel-instance')/owl:ClassAssertion[owl:Class/@IRI='#ISO-13606:EHR_Extract']/owl:NamedIndividual[1]/@IRI"/>
        <xxf:variable name="badApplicationIRI"
            select="if ($applicationIRI = $importModelParameters/applicationIRI) then '' else 'bad-applicationIRI-in-model'"/>

        <!-- Get specialty and class from the ontology.
             (Specialty must be set, class is only set if this is a class model).
             Set importModelParameters -->
        <xxf:variable name="specialtyIRI"
            select="if (exists(xxf:instance('informationModel-instance')/owl:SubClassOf[owl:Class[2]/@IRI='#ISO-13606:Folder']/owl:Class[1]/@IRI)) then xxf:instance('informationModel-instance')/owl:SubClassOf[owl:Class[2]/@IRI='#ISO-13606:Folder']/owl:Class[1]/@IRI[1] else ''"/>
        <xxf:variable name="specialtyId" select="replace(substring($specialtyIRI,2),':','-')"/>
        <xf:setvalue ref="$importModelParameters/specialtyId" value="$specialtyId"/>

        <xxf:variable name="classIRI"
            select="if (exists(xxf:instance('informationModel-instance')/owl:SubClassOf[owl:Class[2]/@IRI='#CityEHR:Class']/owl:Class[1]/@IRI)) then xxf:instance('informationModel-instance')/owl:SubClassOf[owl:Class[2]/@IRI='#CityEHR:Class']/owl:Class[1]/@IRI else ''"/>
        <xxf:variable name="classId" select="replace(substring($classIRI,2),':','-')"/>
        <xf:setvalue ref="$importModelParameters/classId" value="$classId"/>

        <xxf:variable name="modelIRI" select="if ($classIRI!='') then $classIRI else $specialtyIRI"/>
        <xxf:variable name="modelId" select="replace(substring($modelIRI,2),':','-')"/>
        <xf:setvalue ref="$importModelParameters/modelId" value="$modelId"/>

        <xxf:variable name="badSpecialtyIRI"
            select="if ($specialtyIRI ='') then 'bad-specialtyIRI-in-model' else ''"/>

        <!-- Extract language from the ontology -->
        <xxf:variable name="baseLanguageCode" select="$importModelParameters/baseLanguageCode"/>
        <xxf:variable name="languageCode"
            select="if (exists(xxf:instance('informationModel-instance')/owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasLanguage'][1]/owl:Literal)) then xxf:instance('informationModel-instance')/owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasLanguage'][1]/owl:Literal else $baseLanguageCode"/>
        <xf:setvalue
            ref="xxf:instance('applicationControl-instance')/importModelParameters/languageCode"
            value="lower-case($languageCode)"/>

        <xxf:variable name="badLanguageCode"
            select="if ($languageCode ='') then 'bad-languageCode-in-model' else ''"/>

        <!-- Can only import model if there are no errors in the OWL ontology -->
        <xxf:variable name="ontologyError"
            select="if (exists(xxf:instance('informationModel-instance')/owl:ClassAssertion/owl:Class[@IRI='#CityEHR:Error'])) then 'model-ontology-error' else ''"/>

        <xxf:variable name="errorCode"
            select="normalize-space(string-join(($badApplicationIRI,$badSpecialtyIRI,$badLanguageCode,$ontologyError),' '))"/>

        <!-- Abort the import process if there is a problem -->
        <xf:action if="$errorCode != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode" select="$errorCode"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>


    <!-- Application defined action to merge the information model with the common model or the existing model.
         An action in the import-InformationModel process.
         The information model is in informationModel-instance
         Either merges the common model or the existing model - these are loaded to stored-model.
         Note that the information model being imported is the master - any assertions in it take precedence over the existing model
         Only merge if the model is for the baseLanguage
         
         Only merge with the common model if:
            The mergeCommonModel parameter is true.
            The informationModel-instance is not the common model
            There is a stored common model (specialty or class) that matches the informationModel-instance
            And the model is for the baseLanguage
            
         Only merge with the existing model if:
            The mergeExistingModel parameter is true.
            And there is an existing model (specialty or class) that matches the informationModel-instance.
            And the model is for the baseLanguage
         -->
    <xf:action ev:event="importInformationModel-merge">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="modelId" select="$importModelParameters/modelId"/>
        <xxf:variable name="commonModelId" select="$importModelParameters/commonModelId"/>
        <xxf:variable name="commonModelIRI" select="$importModelParameters/commonModelIRI"/>
        <xxf:variable name="mergeCommonModel" select="$importModelParameters/@mergeCommonModel"/>
        <xxf:variable name="mergeExistingModel" select="$importModelParameters/@mergeExistingModel"/>
                 
        <!-- Only need to merge the base language model
             (Language variant models are generated from the base language, which will already have been merged) -->
        <xf:action
            if="$importModelParameters/languageCode = $importModelParameters/baseLanguageCode">

            <!-- Database location of the common model.
                 Can't merge any common models with themselves.
                 commonModelId is the common model specialty - the model to merge is either the common specialty model or the class model in the common specialty -->
            <xxf:variable name="commonModelMergeId"
                select="if ($specialtyId = $modelId) then $commonModelId else $modelId"/>
            <xxf:variable name="commonModelLocation"
                select="if ($commonModelId != '' and $commonModelId != $specialtyId) then concat('/xmlstore/applications/',$applicationId,'/informationModel/',$commonModelId,'/',$commonModelMergeId) else ''"/>

            <!-- Database location of the existing model -->
            <xxf:variable name="existingModelLocation"
                select="if ($specialtyId != '') then concat('/xmlstore/applications/',$applicationId,'/informationModel/',$specialtyId,'/',$modelId) else ''"/>

            <!-- Database location of the model to merge (if any) -->
            <xxf:variable name="mergeModelLocation"
                select="if ($mergeCommonModel='true' and $commonModelLocation !='') then $commonModelLocation
            else if ($mergeExistingModel='true' and $existingModelLocation !='') then $existingModelLocation
            else ''"/>

            <!-- Merge the models if the mergeModelLocation is set -->
            <xf:action if="$mergeModelLocation != ''">

                <!-- Load the storedInformationModel -->
                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                    <xxf:context name="system" select="'ehr'"/>
                    <xxf:context name="storageLocation" select="$mergeModelLocation"/>
                    <xxf:context name="resource"
                        select="xxf:instance('storedInformationModel-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <!-- Call the mergeOntology pipeline to merge the two models.
                 Only if the storedInformationModel was loaded successfully (i.e. was loaded and looks like an OWL/XML ontology)
                 Merge is of informationModel (master) with storedInformationModel (merge).
                 The resulting merged ontology replaces informationModel -->
                <xf:action
                    if="xxf:instance('applicationControl-instance')/status ='' and exists(xxf:instance('informationModel-instance')/owl:Declaration[1]) and exists(xxf:instance('storedInformationModel-instance')/owl:Declaration[1])">

                    <!-- Run pipeline to merge the models -->
                    <xf:dispatch name="merge-ontologies" target="ontology-model">
                        <xxf:context name="master-instance"
                            select="xxf:instance('informationModel-instance')"/>
                        <xxf:context name="merge-instance"
                            select="xxf:instance('storedInformationModel-instance')"/>
                        <xxf:context name="mergeResult-instance"
                            select="xxf:instance('informationModel-instance')"/>
                    </xf:dispatch>
                    <!--
                    <xxf:variable name="xsltPipeline"
                        select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/mergeOntologies.xpl')"/>
                    <xf:insert nodeset="xxf:instance('informationModel-instance')"
                        origin="xxf:call-xpl($xsltPipeline, ('master','merge'), (xxf:instance('informationModel-instance'),xxf:instance('storedInformationModel-instance')) , 'data')/*"/>
-->

                    <!-- If merging with the common model then will now have two subclass declarations for the specialty.
                         Need to remove the subclass declaration for the common model specislty
                    
                            <SubClassOf>
                                <Class IRI="{$commonModelIRI}"/>
                                <Class IRI="#ISO-13606:Folder"/>
                            </SubClassOf>
                    -->
                    <xf:action if="$mergeCommonModel='true'">
                        <xf:delete
                            nodeset="xxf:instance('informationModel-instance')/owl:SubClassOf[owl:Class/@IRI=$commonModelIRI][owl:Class/@IRI='#ISO-13606:Folder']"
                        />
                    </xf:action>

                </xf:action>

            </xf:action>

        </xf:action>
    </xf:action>


    <!-- Application defined action to check expressions in the information model loaded in informationModel-instance.
         An action in the import-informationModel process.
         -->
    <xf:action ev:event="importInformationModel-check">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>

        <!-- Run pipeline to check expressios -->


        <xxf:variable name="xsltPipeline"
            select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/checkExpressions.xpl')"/>
        <xf:insert nodeset="xxf:instance('checkExpressions-instance')"
            origin="xxf:call-xpl($xsltPipeline, ('instance','parameters'), (xxf:instance('informationModel-instance'),xxf:instance('view-parameters-instance')) , 'data')"/>

    </xf:action>


    <!-- Application defined action to save the information model to the database.
         An action in the import-informationModel process.
         The informationModel-instance is written to the modelLocation
         which is constructed from applicationId, specialtyId and modelId
         -->
    <xf:action ev:event="importInformationModel-save">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="modelId" select="$importModelParameters/modelId"/>

        <!-- Set the language variant location (if model is not for the base language) -->
        <xxf:variable name="languageVariantLocation"
            select="if ($importModelParameters/languageCode != $importModelParameters/baseLanguageCode) then concat('/variants/',$importModelParameters/languageCode) else ''"/>

        <!-- Set the storgage location for the information model -->
        <xxf:variable name="modelLocation"
            select="if (($applicationId,$specialtyId,$modelId) = '') then '' else concat('/xmlstore/applications/',$applicationId,$languageVariantLocation,'/informationModel/',$specialtyId,'/',$modelId)"/>

        <!-- Save the model to the database -->
        <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$modelLocation"/>
            <xxf:context name="resource" select="xxf:instance('informationModel-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Update the specialtyList if the model was saved successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status = ''">
            <xf:dispatch name="get-specialtyList" target="application-model">
                <xxf:context name="applicationId" select="$applicationId"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

        <!-- Abort the import process if the model was not saved successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>

    </xf:action>


    <!-- Application defined action to generate the data dictionary (for specialty models only?).
         An action in the import-InformationModel process.
         Dictionaries are generated for both specialty and class models.
         Run pipeline to generate the dictionary from the model.
         Save the dictionary to the database.
         -->
    <xf:action ev:event="importInformationModel-generateDictionary">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="modelId" select="$importModelParameters/modelId"/>
        <xxf:variable name="commonModelIRI" select="$importModelParameters/commonModelIRI"/>

        <!-- Call pipeline to generate dictionary  -->
        <xf:dispatch name="invoke-pipeline" target="pageNavigation-model">
            <xxf:context name="pipeline" select="'convertOWL2DataDictionary.xpl'"/>
            <xxf:context name="input-instance" select="xxf:instance('informationModel-instance')"/>
            <xxf:context name="return-instance" select="xxf:instance('modelDictionary-instance')"/>
        </xf:dispatch>

        <!-- Check the pipeline return -->
        <xxf:variable name="pipelineReturn" select="xxf:instance('modelDictionary-instance')/name()"/>

        <!-- Abort the process if there was an error in the pipeline -->
        <xf:action if="not($pipelineReturn ='EHR_Extract')">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode" select="'failed-generateDictionary'"/>
                <xxf:context name="errorInstance" select="xxf:instance('modelDictionary-instance')"
                />
            </xf:dispatch>
        </xf:action>

        <xf:action if="$pipelineReturn ='EHR_Extract'">
            <!-- Check that there are no errors in the dictionary -->
            <xxf:variable name="dictionaryErrorSet"
                select="xxf:instance('modelDictionary-instance')//cityEHR:error | xxf:instance('modelDictionary-instance')//@cityEHR:error"/>

            <xf:action if="exists($dictionaryErrorSet)">
                <!-- Replace dictionary with the errors -->
                <xf:delete nodeset="xxf:instance('applicationError-instance')/*"/>

                <xf:action xxf:iterate="$dictionaryErrorSet">
                    <xxf:variable name="dictionaryError" select="."/>
                    <xf:insert context="xxf:instance('applicationError-instance')" nodeset="*"
                        at="last()" position="after"
                        origin="xxf:instance('applicationControl-instance')/error"/>
                    <xf:setvalue ref="xxf:instance('applicationError-instance')/*[last()]"
                        value="$dictionaryError"/>
                </xf:action>

                <xf:dispatch name="abort-process" target="process-model">
                    <xxf:context name="errorCode" select="'errors-reported-generateDictionary'"/>
                    <xxf:context name="errorInstance"
                        select="xxf:instance('applicationError-instance')"/>
                </xf:dispatch>
            </xf:action>

            <xf:action if="not(exists($dictionaryErrorSet))">

                <!-- Set the commonModelIRI in the dictionary.
                     The commonModelCode attribute is created but not set in the OWL2DataDictionary XSLT. -->
                <xf:setvalue ref="xxf:instance('modelDictionary-instance')/@commonModelCode"
                    value="$commonModelIRI"/>

                <!-- Set the language variant location (if model is not for the base language) -->
                <xxf:variable name="languageVariantLocation"
                    select="if ($importModelParameters/languageCode != $importModelParameters/baseLanguageCode) then concat('/variants/',$importModelParameters/languageCode) else ''"/>

                <!-- Set the storgage location for the dictionary -->
                <xxf:variable name="dictionaryLocation"
                    select="if (($applicationId,$specialtyId,$modelId) = '') then '' else concat('/xmlstore/applications/',$applicationId,$languageVariantLocation,'/systemConfiguration/',$specialtyId,'/dictionary/',$modelId)"/>

                <!-- Save the dictionary to the database -->
                <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                    <xxf:context name="system" select="'ehr'"/>
                    <xxf:context name="storageLocation" select="$dictionaryLocation"/>
                    <xxf:context name="resource" select="xxf:instance('modelDictionary-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <!-- Abort the import process if the dictionary was not saved successfully-->
                <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
                    <xf:dispatch name="abort-process" target="process-model">
                        <xxf:context name="errorCode"
                            select="xxf:instance('applicationControl-instance')/status"/>
                    </xf:dispatch>
                </xf:action>
            </xf:action>
        </xf:action>

    </xf:action>


    <!-- Application defined action to create compositions (for specialty models only).
         Run XSLT to convert informationModel-instance (OWL) to composition set.
         An action in the import-InformationModel process.
         -->
    <xf:action ev:event="importInformationModel-createCompositions">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="classId" select="$importModelParameters/classId"/>

        <!-- Only for specialty models - classId is not set -->
        <xf:action if="$classId =''">

            <!-- Call pipleline to generate composition set -->
            <xf:dispatch name="invoke-pipeline" target="pageNavigation-model">
                <xxf:context name="pipeline" select="'convertOWL2CompositionSet.xpl'"/>
                <xxf:context name="input-instance"
                    select="xxf:instance('informationModel-instance')"/>
                <xxf:context name="return-instance" select="xxf:instance('compositionSet-instance')"
                />
            </xf:dispatch>

            <!--
            <xxf:variable name="xsltPipeline"
                select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/convertOWL2CompositionSet.xpl')"/>
            <xf:insert nodeset="xxf:instance('compositionSet-instance')"
                origin="xxf:call-xpl($xsltPipeline, ('instance','view-parameters'), (xxf:instance('informationModel-instance'),xxf:instance('view-parameters-instance')) , 'data')"/>
-->
            <!-- Check the pipeline return -->
            <xxf:variable name="pipelineReturn"
                select="xxf:instance('compositionSet-instance')/name()"/>

            <!-- Abort the process if there was an error in the pipeline -->
            <xf:action if="not($pipelineReturn ='compositionSet')">
                <xf:dispatch name="abort-process" target="process-model">
                    <xxf:context name="errorCode" select="'failed-convertOWL2CompositionSet'"/>
                    <xxf:context name="errorInstance"
                        select="xxf:instance('compositionSet-instance')"/>
                </xf:dispatch>
            </xf:action>

            <!-- The pipeline completed successfully -->
            <xf:action if="$pipelineReturn ='compositionSet'">
                <!-- Set the language variant location (if model is not for the base language) -->
                <xxf:variable name="languageVariantLocation"
                    select="if ($importModelParameters/languageCode != $importModelParameters/baseLanguageCode) then concat('/variants/',$importModelParameters/languageCode) else ''"/>

                <!-- Record the compsition and status in the process execution log -->
                <xf:dispatch name="log-processMessage" target="process-model">
                    <xxf:context name="message"
                        select="concat('compositionSet (',xs:string(count(xxf:instance('compositionSet-instance')/cda:ClinicalDocument)),') ',xxf:instance('compositionSet-instance')/name())"
                    />
                </xf:dispatch>

                <!-- Now iterate through the composition set and import each composition -->
                <xf:action
                    xxf:iterate="xxf:instance('compositionSet-instance')/cda:ClinicalDocument">
                    <xxf:variable name="composition" select="."/>
                    <xxf:variable name="compositionIRI" select="$composition/cda:id/@extension"/>
                    <xxf:variable name="compositionId"
                        select="replace(substring($compositionIRI,2),':','-')"/>

                    <!-- Clear out the composition-instance -->
                    <xf:delete nodeset="xxf:instance('composition-instance')/*"/>

                    <!-- Set the composition-instance -->
                    <xf:action xxf:iterate="$composition/*">
                        <xxf:variable name="compositionNode" select="."/>
                        <xf:insert context="xxf:instance('composition-instance')" nodeset="*"
                            at="last()" position="after" origin="$compositionNode"/>
                    </xf:action>

                    <!-- Set the storage location for the composition -->
                    <xxf:variable name="compositionLocation"
                        select="if (($applicationId,$specialtyId,$compositionId) = '') then '' else concat('/xmlstore/applications/',$applicationId,$languageVariantLocation,'/systemConfiguration/',$specialtyId,'/compositions/',$compositionId)"/>

                    <!-- Save the composition to the database -->
                    <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
                        <xxf:context name="system" select="'ehr'"/>
                        <xxf:context name="storageLocation" select="$compositionLocation"/>
                        <xxf:context name="resource" select="xxf:instance('composition-instance')"/>
                        <xxf:context name="status"
                            select="xxf:instance('applicationControl-instance')/status"/>
                    </xf:dispatch>

                    <xxf:variable name="writeStatus"
                        select="if (xxf:instance('applicationControl-instance')/status='') then 'stored' else xxf:instance('applicationControl-instance')/status"/>

                    <!-- Record the compsition and status in the process execution log -->
                    <xf:dispatch name="log-processMessage" target="process-model">
                        <xxf:context name="message"
                            select="concat($compositionIRI,' / ',$writeStatus)"/>
                    </xf:dispatch>
                </xf:action>

            </xf:action>
        </xf:action>
    </xf:action>

    <!-- Application defined action to rebuild directories (for specialty models only).
         Rebuild for any language - creates the variabt directories, as required
         An action in the import-InformationModel process.
         -->
    <xf:action ev:event="importInformationModel-rebuildDirectories">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationIRI" select="$importModelParameters/applicationIRI"/>
        <xxf:variable name="classId" select="$importModelParameters/classId"/>

        <!-- Debugging
        <xf:message ref="concat($importModelParameters/languageCode,' / ',$importModelParameters/baseLanguageCode,' / ',$importModelParameters/@rebuildDirectories)"/>
        -->

        <!-- Only for the base language -->
        <xf:action
            if="$importModelParameters/languageCode = $importModelParameters/baseLanguageCode">

            <!-- Only for specialty models - classId is not set -->
            <xf:action if="$classId =''">

                <!-- Set the list of directories in the dictionary (already loaded to modelDictionary-instance) -->
                <xf:dispatch name="set-directoryList" target="application-model">
                    <xxf:context name="dictionary-instance"
                        select="xxf:instance('modelDictionary-instance')"/>
                    <xxf:context name="directoryList-instance"
                        select="xxf:instance('directoryList-instance')"/>
                </xf:dispatch>

                <!-- Only rebuild directories if this option is set -->
                <xf:action if="$importModelParameters/@rebuildDirectories='true'">
                    <xf:dispatch name="rebuild-directories" target="application-model">
                        <xxf:context name="applicationIRI" select="$applicationIRI"/>
                        <xxf:context name="dictionary-instance"
                            select="xxf:instance('modelDictionary-instance')"/>
                        <xxf:context name="directoryList-instance"
                            select="xxf:instance('directoryList-instance')"/>
                        <xxf:context name="languageCode"
                            select="$importModelParameters/languageCode"/>
                    </xf:dispatch>
                </xf:action>

            </xf:action>

        </xf:action>
    </xf:action>


    <!-- Application defined action to update the language packs.
         An action in the import-InformationModel process.
         Only when importing the base language model
         Iterate through the existing language packs for this model.
         Load the language pack
         Add any terms in the new model that don't exist 
         Save the language pack.
         -->
    <xf:action ev:event="importInformationModel-updateLanguagePacks">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>

        <!-- Only need to update language packs when the base language model is imported -->
        <xf:action
            if="$importModelParameters/languageCode = $importModelParameters/baseLanguageCode">

            <!-- Iterate through the languaages supported by the application -->
            <xxf:variable name="supportedLanguageList"
                select="xxf:instance('application-parameters-instance')/languagePacks/language/@code"/>
            <xf:action xxf:iterate="$supportedLanguageList">
                <xxf:variable name="languageCode" select="lower-case(.)"/>

                <!-- Load the informationModel language pack -->
                <xf:dispatch name="load-modelLanguagePack" target="application-model">
                    <xxf:context name="applicationIRI"
                        select="$importModelParameters/applicationIRI"/>
                    <xxf:context name="languageCode" select="$languageCode"/>
                    <xxf:context name="languagePack-instance"
                        select="xxf:instance('workingLanguagePack-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <!-- If the languagePack was loaded -->
                <xf:action if="xxf:instance('applicationControl-instance')/status=''">
                    <!-- Update language pack from the information model 
                        (Uses workingLanguagePack-instance, so don't need to pass as a parameter) -->
                    <xf:dispatch name="update-modelLanguagePack" target="application-model">
                        <xxf:context name="informationModel-instance"
                            select="xxf:instance('informationModel-instance')"/>
                    </xf:dispatch>

                    <!-- Save the language pack -->
                    <xf:dispatch name="save-modelLanguagePack" target="application-model">
                        <xxf:context name="applicationIRI"
                            select="$importModelParameters/applicationIRI"/>
                        <xxf:context name="languageCode" select="$languageCode"/>
                        <xxf:context name="languagePack-instance"
                            select="xxf:instance('workingLanguagePack-instance')"/>
                        <xxf:context name="status"
                            select="xxf:instance('applicationControl-instance')/status"/>
                    </xf:dispatch>
                </xf:action>

            </xf:action>

        </xf:action>
    </xf:action>


    <!-- Application defined action to clear the form cache (for specialty models only).
         An action in the import-InformationModel process.
         -->
    <xf:action ev:event="importInformationModel-clearFormCache">
        <xxf:variable name="importModelParameters"
            select="xxf:instance('applicationControl-instance')/importModelParameters"/>
        <xxf:variable name="applicationId" select="$importModelParameters/applicationId"/>
        <xxf:variable name="specialtyId" select="$importModelParameters/specialtyId"/>
        <xxf:variable name="classId" select="$importModelParameters/classId"/>

        <!-- Set the language variant location (if model is not for the base language) -->
        <xxf:variable name="languageVariantLocation"
            select="if ($importModelParameters/languageCode != $importModelParameters/baseLanguageCode) then concat('/variants/',$importModelParameters/languageCode) else ''"/>

        <!-- Only for specialty models - classId is not set -->
        <xf:action if="$classId =''">
            <!-- Set the cache location -->
            <xxf:variable name="cacheLocation"
                select="if (($applicationId,$specialtyId) = '') then '' else concat('/xmlstore/applications/',$applicationId,$languageVariantLocation,'/systemConfiguration/',$specialtyId,'/cache')"/>

            <!-- Delete the form cache collection in the database -->
            <xf:dispatch name="dal-delete" target="databaseAccessLayer-model">
                <xxf:context name="system" select="'ehr'"/>
                <xxf:context name="storageLocation" select="$cacheLocation"/>
                <xxf:context name="status"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>

        </xf:action>

    </xf:action>



    <!-- ============= Language Packs ================================================================= 
         Language packs are maintained for the application-parameters, informationModel and directories
         (as well as for the system-parameters)
         Here just the languagePack for the informationModel
         
         There is one languagePack for each target language, covering terms in all specialty and class models
         (So this may get very large, but using one languagePack means that terms are consistent across all contexts).
         
         There ae three basic actions:
            generate-modelLanguagePack - create a new laguage pack, containing all base language terms
            update-modelLanguagePack - update the language pack with new terms from the base language
            merge-modelLanguagePack - merge the language pack with terms from an imported pack (after translation)
            
         When a language pack is exported, then it can constrained to an individual model (class or specialty)
            
            
         ============================================================================================== -->

    <!-- Instances for language packs in OWL/XML - languagePack, storedLanguagePack -->
    <xf:instance id="languagePack-instance">
        <owl:Ontology/>
    </xf:instance>
    <xf:instance id="workingLanguagePack-instance">
        <owl:Ontology/>
    </xf:instance>
    <xf:instance id="storedLanguagePack-instance">
        <owl:Ontology/>
    </xf:instance>
    <xf:instance id="exportLanguagePack-instance">
        <owl:Ontology/>
    </xf:instance>


    <xf:instance id="shippedLanguagePackList-instance">
        <directoryList/>
    </xf:instance>


    <!-- Application defined action to initialize the list of shipped language packs.
         Used in create-application and import-shippedResources.
         Gets the shippedDirectoryList -->
    <xf:action ev:event="initialize-shippedLanguagePackList">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <xf:dispatch name="dal-getStaticResourceList" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation"
                select="concat('/applications/',$applicationId,'/languagePacks')"/>
            <xxf:context name="staticResourceList-instance"
                select="xxf:instance('shippedLanguagePackList-instance')"/>
            <xxf:context name="fileTemplate"
                select="xxf:instance('applicationControl-instance')/importShippedResources/languagePackFile"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

    </xf:action>


    <!-- Application defined action to check whether the languagePack exists.
         Returns true or false.
         -->
    <xf:action ev:event="modelLanguagePack-exists">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the language pack location in the database -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/',$languageCode,'/informationModel')"/>

        <!-- Check whether languagePack exists -->
        <xf:dispatch name="resource-exists" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$languagePackLocation"/>
            <xxf:context name="result" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set return status -->
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>
    </xf:action>


    <!-- Application defined action to load the languagePack template 
         Loads to workingLanguagePack-instance.
         -->
    <xf:action ev:event="load-languagePackTemplate">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="baseLanguageCode" select="event('baseLanguageCode')"/>

        <!-- Load the languagePack template to workingLanguagePack-instance -->
        <xxf:variable name="languagePackTemplateLocation"
            select="'/templates/cityEHRlanguagePack.xml'"/>
        <xf:dispatch name="dal-readStaticResource" target="databaseAccessLayer-model">
            <xxf:context name="staticResourceLocation" select="$languagePackTemplateLocation"/>
            <xxf:context name="resource" select="xxf:instance('workingLanguagePack-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set applicationIRI, languageCode and baseLanguageCode.
             These are in specific assertions in the template, represented as $applicationIRI, $languageCode and $baseLanguageCode.
             So just need to find and replace them. -->
        <xf:action
            xxf:iterate="xxf:instance('workingLanguagePack-instance')//@IRI[.='$applicationIRI']">
            <xf:setvalue ref="." value="$applicationIRI"/>
        </xf:action>
        <xf:action
            xxf:iterate="xxf:instance('workingLanguagePack-instance')//@xml:lang[.='$languageCode']">
            <xf:setvalue ref="." value="$languageCode"/>
        </xf:action>
        <xf:action xxf:iterate="xxf:instance('workingLanguagePack-instance')//*[.='$languageCode']">
            <xf:setvalue ref="." value="$languageCode"/>
        </xf:action>
        <xf:action
            xxf:iterate="xxf:instance('workingLanguagePack-instance')//@xml:lang[.='$baseLanguageCode']">
            <xf:setvalue ref="." value="$baseLanguageCode"/>
        </xf:action>
        <xf:action
            xxf:iterate="xxf:instance('workingLanguagePack-instance')//*[.='$baseLanguageCode']">
            <xf:setvalue ref="." value="$baseLanguageCode"/>
        </xf:action>

    </xf:action>


    <!-- Application defined action to generate a languagePack from a list of information models.
         languagePack-instance is passed with the existing language pack and is then set as the return, once generated
         Merges with the languagePack in the target language, if one was passed as a parameter
         -->
    <xf:action ev:event="generate-modelLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="informationModelList-instance"
            select="event('informationModelList-instance')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="baseLanguageCode" select="event('baseLanguageCode')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <!-- Load the languagePack template to workingLanguagePack-instance -->
        <xf:dispatch name="load-languagePackTemplate" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="languageCode" select="$languageCode"/>
            <xxf:context name="baseLanguageCode" select="$baseLanguageCode"/>
        </xf:dispatch>

        <!-- Iterate through the models -->
        <xf:action xxf:iterate="$informationModelList-instance/informationModel">
            <xxf:variable name="informationModel" select="."/>

            <xf:action if="xxf:instance('applicationControl-instance')/status=''">

                <!-- Load the information model into the storedInformationModel-instance -->
                <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
                    <xxf:context name="system" select="'ehr'"/>
                    <xxf:context name="physicalClusterNode" select="''"/>
                    <xxf:context name="storageLocation" select="$informationModel/handle"/>
                    <xxf:context name="resource"
                        select="xxf:instance('storedInformationModel-instance')"/>
                    <xxf:context name="status"
                        select="xxf:instance('applicationControl-instance')/status"/>
                </xf:dispatch>

                <!-- Generate language pack for the model.
                     (Uses workingLanguagePack-instance, so don't need to pass as a parameter) -->
                <xf:dispatch name="update-modelLanguagePack" target="application-model">
                    <xxf:context name="informationModel-instance"
                        select="xxf:instance('storedInformationModel-instance')"/>
                </xf:dispatch>
            </xf:action>
        </xf:action>


        <!-- Set the return languagePack-instance and status-->
        <xf:insert nodeset="$languagePack-instance"
            origin="xxf:instance('workingLanguagePack-instance')"/>
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>


    <!-- Application defined action to generate a languagePack for export.
         Generates in workingLanguagePack-instance
         The exportLanguagePack-instance contains all terms from informationModel-instance in the base language
         Merged with the terms in the target language, from the languagePack-instance
         -->
    <xf:action ev:event="generate-exportLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="baseLanguageCode" select="event('baseLanguageCode')"/>
        <xxf:variable name="informationModel-instance" select="event('informationModel-instance')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>

        <!-- Load the languagePack template to workingLanguagePack-instance -->
        <xf:dispatch name="load-languagePackTemplate" target="application-model">
            <xxf:context name="applicationIRI" select="$applicationIRI"/>
            <xxf:context name="languageCode" select="$languageCode"/>
            <xxf:context name="baseLanguageCode" select="$baseLanguageCode"/>
        </xf:dispatch>

        <!-- The terms in the information model (resource-instance).
             These will be in the baseLanguage -->
        <xxf:variable name="modelTermIRIList"
            select="$informationModel-instance//owl:ClassAssertion[owl:Class/@IRI='#CityEHR:Term']/owl:NamedIndividual/@IRI"/>

        <!-- Iterate through the terms in the information model -->
        <xf:action xxf:iterate="$modelTermIRIList">
            <xxf:variable name="termIRI" select="."/>

            <!-- baseLanguageLiteral is assertion for the literal of the term, in the base language -->
            <xxf:variable name="baseLanguageLiteral"
                select="$informationModel-instance//owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasValue'][owl:NamedIndividual/@IRI=$termIRI]"/>
            <xf:action if="exists($baseLanguageLiteral)">
                <xf:insert context="xxf:instance('workingLanguagePack-instance')" nodeset="*"
                    at="last()" position="after" origin="$baseLanguageLiteral"/>
            </xf:action>

            <!-- languagePackLiteral is assertion in the language pack for the literal of the term, in the targter language 
                 This may not exist, if the term has not been translated -->
            <xxf:variable name="languagePackLiteral"
                select="$languagePack-instance//owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasValue'][owl:NamedIndividual/@IRI=$termIRI][owl:Literal/@xml:lang=$languageCode]"/>
            <xf:action if="exists($languagePackLiteral)">
                <xf:insert context="xxf:instance('workingLanguagePack-instance')" nodeset="*"
                    at="last()" position="after" origin="$languagePackLiteral"/>
            </xf:action>

        </xf:action>

    </xf:action>


    <!-- Application defined action to update a languagePack from an information model.
         The language pack is updated in workingLanguagePack-instance (which does not need to be empty)
         
         The language pack contains one assertion for every term in the information model (all specialties and classes)
         The assertion is either
            In the target language of the language pack
            OR in the base language (if a translation hasn't been made)
         .
         -->
    <xf:action ev:event="update-modelLanguagePack">
        <xxf:variable name="informationModel-instance" select="event('informationModel-instance')"/>

        <!-- Iterate through terms in the informationModel-instance, inserting displayNames into workingLanguagePack-instance
        
            <ClassAssertion>
                <Class IRI="#CityEHR:Term"/>
                <NamedIndividual IRI="#CityEHR:Term:Beightonscore"/>
            </ClassAssertion>
            
            <DataPropertyAssertion>
                <DataProperty IRI="#hasValue"/>
                <NamedIndividual IRI="#CityEHR:Term:Beightonscore"/>
                <Literal xml:lang="en-gb" datatypeIRI="&amp;rdf;PlainLiteral">Beighton score</Literal>
            </DataPropertyAssertion>
        -->
        <xf:action
            xxf:iterate="$informationModel-instance/owl:ClassAssertion[owl:Class/@IRI='#CityEHR:Term']">
            <xxf:variable name="termIRI" select="owl:NamedIndividual/@IRI"/>
            <xxf:variable name="dataPropertyAssertion"
                select="$informationModel-instance/owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasValue'][owl:NamedIndividual/@IRI=$termIRI]"/>

            <!-- Check whether the term value is already asserted in workingLanguagePack-instance -->
            <xxf:variable name="termExists"
                select="if (exists(xxf:instance('workingLanguagePack-instance')/owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasValue'][owl:NamedIndividual/@IRI=$termIRI])) then 'true' else 'false'"/>

            <xf:action if="$termExists='false'">
                <xf:insert context="xxf:instance('workingLanguagePack-instance')" nodeset="*"
                    at="last()" position="after" origin="$dataPropertyAssertion"/>
            </xf:action>
        </xf:action>

    </xf:action>


    <!-- Application defined action to load a languagePack from the database.
         Loads a languagePack, given the applicationIRI and type (informationModel or directory).
         The model is loaded  to storedLanguagePack-instance.
         Then returned in languagePack-instance.
         Sets status to an error code if the languagePack cannot be read.       
         -->
    <xf:action ev:event="load-modelLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the language pack location in the database -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/',$languageCode,'/informationModel')"/>

        <!-- Read language pack from the database -->
        <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$languagePackLocation"/>
            <xxf:context name="resource" select="xxf:instance('storedLanguagePack-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the return languagePack-instance and status-->
        <xf:insert nodeset="$languagePack-instance"
            origin="xxf:instance('storedLanguagePack-instance')"/>
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>


    <!-- Application defined action to save a languagePack to the database.
         applicationIRI and languageCode must already be checked to match the languagePack-instance
         Sets status to an error code if the languagePack cannot be written.       
         -->
    <xf:action ev:event="save-modelLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the language pack location in the database -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/',$languageCode,'/informationModel')"/>

        <!-- Write language pack to the database -->
        <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$languagePackLocation"/>
            <xxf:context name="resource" select="$languagePack-instance"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the return status-->
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>


    <!-- Application defined action to apply a languagePack to a list of information models.
        
         The common model (if it exists) must be the first model in the informationModelList
         which is a list of informationModel elements of the form:
         
         <informationModel>
            <specialtyIRI/>
            <specialtyDisplayName/>
            <modelIRI/>
            <informationModelType/>
            <modelDisplayName/>
            <handle/>
         </informationModel>
               
         Iterate through the information models to:
             Load the information model 
             Merge the language pack and information model
             Then invoke import-informationModel for the merged model
             
         The iteration is achieved by passing the information model list as context to the apply-languagePack process.
         This then invokes import-informationModel as a sub-process for each model
         So the parameters for import-informationModel must be set up here
         -->
    <xf:action ev:event="apply-languagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="commonModelIRI" select="event('commonModelIRI')"/>
        <xxf:variable name="informationModelList-instance"
            select="event('informationModelList-instance')"/>
        <xxf:variable name="baseLanguageCode" select="event('baseLanguageCode')"/>
        <xxf:variable name="languageCode" select="event('languageCode')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>
        <xxf:variable name="commonModelId" select="replace(substring($commonModelIRI,2),':','-')"/>

        <!-- Extract languageCode from languagePack -->
        <xxf:variable name="languagePackLanguageCode"
            select="lower-case($languagePack-instance/owl:DataPropertyAssertion[owl:DataProperty/@IRI='#hasLanguage']/owl:Literal)"/>

        <!-- Language not set correctly - set error status -->
        <xf:action if="$languageCode != $languagePackLanguageCode">
            <xf:setvalue ref="$status" value="'badApplyLanguagePackParameters'"/>
        </xf:action>

        <!-- Language set correctly - apply the language pack to each model 
             Iterate through the models -->
        <xf:action if="$languageCode = $languagePackLanguageCode">

            <!-- Set parameters to be used in the import-shippedResources process -->
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationIRI"
                value="$applicationIRI"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/applicationId"
                value="$applicationId"/>

            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeExistingModel"
                value="false()"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/@mergeCommonModel"
                value="false()"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/@importMedia"
                value="false()"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/@importDirectories"
                value="false()"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/@rebuildDirectories"
                value="false()"/>

            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/baseLanguageCode"
                value="lower-case($baseLanguageCode)"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/languageCode"
                value="lower-case($languageCode)"/>

            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelIRI"
                value="$commonModelIRI"/>
            <xf:setvalue
                ref="xxf:instance('applicationControl-instance')/importModelParameters/commonModelId"
                value="$commonModelId"/>

            <!-- Set the common model as the first in the information model list -->
            <xf:action if="$commonModelIRI!=''">
                <xxf:variable name="commonInformationModei"
                    select="$informationModelList-instance/informationModel[modelIRI=$commonModelIRI]"/>
                <xf:insert context="$informationModelList-instance" nodeset="informationModel"
                    origin="$commonInformationModei" at="1" position="before"/>
                <xf:delete nodeset="$commonInformationModei"/>
            </xf:action>

            <!-- Run the process to apply language pack to each information model -->
            <xf:dispatch name="run-process" target="process-model">
                <xxf:context name="processName" select="'apply-languagePack'"/>
                <xxf:context name="contextSet"
                    select="$informationModelList-instance/informationModel"/>
                <xxf:context name="completionActionModel" select="''"/>
                <xxf:context name="completionActionName" select="''"/>
            </xf:dispatch>

        </xf:action>
    </xf:action>


    <!-- Application defined action to clear the form cache (for specialty models only).
         An action in the apply-languagePack process.
         Context is the informationModel element from informationModelList-instance
         Sets up informationModel-instance before sub-process import-informationModel is invoked
         -->
    <xf:action ev:event="applyLanguagePack-applyToModel">
        <xxf:variable name="informationModel" select="event('context')"/>

        <!-- Log the context of this action in the process -->
        <xf:dispatch name="log-processActionContext" target="process-model">
            <xxf:context name="context" select="$informationModel/modelIRI"/>
        </xf:dispatch>

        <!-- Load the information model into the storedInformationModel-instance -->
        <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="physicalClusterNode" select="''"/>
            <xxf:context name="storageLocation" select="$informationModel/handle"/>
            <xxf:context name="resource" select="xxf:instance('storedInformationModel-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <xf:action if="xxf:instance('applicationControl-instance')/status=''">
            <!-- Call the mergeOntology pipeline to merge the two models.
                 The merged ontology is put into informationModel-instance so that it is ready for further processing -->

            <xf:dispatch name="merge-ontologies" target="ontology-model">
                <xxf:context name="master-instance" select="xxf:instance('languagePack-instance')"/>
                <xxf:context name="merge-instance"
                    select="xxf:instance('storedInformationModel-instance')"/>
                <xxf:context name="mergeResult-instance"
                    select="xxf:instance('informationModel-instance')"/>
            </xf:dispatch>
            <!--
            <xxf:variable name="xsltPipeline"
                select="concat(xxf:instance('view-parameters-instance')/appPath, '/pipelines/mergeOntologies.xpl')"/>
            <xf:insert nodeset="xxf:instance('informationModel-instance')"
                origin="xxf:call-xpl($xsltPipeline, ('master','merge'), (xxf:instance('languagePack-instance'),xxf:instance('storedInformationModel-instance')) , 'data')/*"
            />
-->
        </xf:action>

        <!-- Debugging - save to xmlCache -->
        <xxf:variable name="userId" select="xxf:instance('view-parameters-instance')/userId"/>
        <xxf:variable name="cacheStorageLocation"
            select="concat('/xmlstore/users/',$userId,'/xmlCache')"/>

        <!-- Write instance to the xml cache for debugging.
             Return the URL for the resource in the database (in view-parameters-instance) -->
        <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$cacheStorageLocation"/>
            <xxf:context name="resource" select="xxf:instance('informationModel-instance')"/>
            <xxf:context name="resourceURL"
                select="xxf:instance('view-parameters-instance')/resourceHandle"/>
            <xxf:context name="status"
                select="xxf:instance('applicationControl-instance')/debugStatus"/>
        </xf:dispatch>


        <!-- Abort the apply language pack process if the model was not loaded successfully-->
        <xf:action if="xxf:instance('applicationControl-instance')/status != ''">
            <xf:dispatch name="abort-process" target="process-model">
                <xxf:context name="errorCode"
                    select="xxf:instance('applicationControl-instance')/status"/>
            </xf:dispatch>
        </xf:action>


    </xf:action>


    <!-- Application defined action to load a languagePack for application parameters.
         There is only one language pack for the applicationIRI (contains all languages)
         The model is loaded  to storedLanguagePack-instance.
         Then returned in languagePack-instance.
         Sets status to an error code if the languagePack cannot be read.       
         -->
    <xf:action ev:event="load-applicationParametersLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the language pack location in the database -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/application-parameters')"/>

        <!-- Read language pack from the database -->
        <xf:dispatch name="dal-read" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$languagePackLocation"/>
            <xxf:context name="resource" select="xxf:instance('storedLanguagePack-instance')"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the return languagePack-instance and status-->
        <xf:insert nodeset="$languagePack-instance"
            origin="xxf:instance('storedLanguagePack-instance')"/>
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>


    <!-- Application defined action to save a languagePack for application parameters.
         Sets status to an error code if the languagePack cannot be written.       
         -->
    <xf:action ev:event="save-applicationParametersLanguagePack">
        <xxf:variable name="applicationIRI" select="event('applicationIRI')"/>
        <xxf:variable name="languagePack-instance" select="event('languagePack-instance')"/>
        <xxf:variable name="status" select="event('status')"/>

        <xxf:variable name="applicationId" select="replace(substring($applicationIRI,2),':','-')"/>

        <!-- Set the language pack location in the database -->
        <xxf:variable name="languagePackLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/languagePack/application-parameters')"/>

        <!-- Write language pack to the database -->
        <xf:dispatch name="dal-write" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$languagePackLocation"/>
            <xxf:context name="resource" select="$languagePack-instance"/>
            <xxf:context name="status" select="xxf:instance('applicationControl-instance')/status"/>
        </xf:dispatch>

        <!-- Set the return status-->
        <xf:setvalue ref="$status" value="xxf:instance('applicationControl-instance')/status"/>

    </xf:action>



    <!-- ========= Set up when model is first loaded ========= 
         ===================================================== -->
    <xf:action ev:event="xforms-model-construct-done">
        <!-- Not doing anything here -->
    </xf:action>


</xf:model>
