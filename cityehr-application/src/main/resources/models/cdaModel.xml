<?xml version="1.0" encoding="UTF-8"?>
<!-- 
    *********************************************************************************************************
    cityEHR
    cdaModel.xml
    
    Xforms model containing stuff for loading and instantiating CDA documents.
    Used for creating reports in cityEHRFolder-Views and for exporting data in cityEHRCohortSearch
    2016-05-19 - could refactor compositionMainModel to use this at some stage in the future.
    
    Copyright (C) 2013-2021 John Chelsom.
    
    This program is free software; you can redistribute it and/or modify it under the terms of the
    GNU Lesser General Public License as published by the Free Software Foundation; either version
    2.1 of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU Lesser General Public License for more details.
    
    The full text of the license is available at http://www.gnu.org/copyleft/lesser.html
    **********************************************************************************************************
-->

<xf:model id="cda-model" xmlns:xf="http://www.w3.org/2002/xforms"
    xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:xxf="http://orbeon.org/oxf/xml/xforms"
    xmlns:exforms="http://www.exforms.org/exf/1-0" xmlns:widget="http://orbeon.org/oxf/xml/widget"
    xmlns:fr="http://orbeon.org/oxf/xml/form-runner" xmlns:f="http://orbeon.org/oxf/xml/formatting"
    xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:exist="http://exist.sourceforge.net/NS/exist" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xxi="http://orbeon.org/oxf/xml/xinclude" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:math="http://exslt.org/math" xmlns:cda="urn:hl7-org:v3"
    xmlns:iso-13606="http://www.iso.org/iso-13606"
    xmlns:cityEHR="http://openhealthinformatics.org/ehr">


    <!-- === Control for management of cda document -->
    <xf:instance id="cdaControl-instance">
        <control xmlns="">
            <status/>
            <compositionHandle/>
            <!-- formStatus is used to stop ev:xforms-value-changed from triggering when the form is being set up -->
            <formStatus><!-- loaded | error | ready --></formStatus>
            <!-- Specialty is set for views and cohort queries (not always the same ad the session specialty -->
            <specialtyIRI/>
            <specialtyId/>
            <!-- Template for SDS -->
            <cda:entryRelationship cityEHR:origin="" cityEHR:focus=""/>
            <!-- For degugging -->
            <prefilledEntrySet/>
            <test/>
        </control>
    </xf:instance>


    <!-- === form-instance 
         This holds the cda document
         ========================================================= -->

    <xf:instance id="form-instance">
        <cda:ClinicalDocument xmlns="urn:hl7-org:v3">
            <!-- Template loaded from xmlstore -->
        </cda:ClinicalDocument>
    </xf:instance>

    <!-- Bindings on the form-instance, covers:
        data type for entry
        calculated values
        default values
        conditional display of section/entry/element
        constraints
        required values
        read-only on CRD multipleEntries
    -->

    <xf:bind nodeset="xxf:instance('form-instance')">

        <!-- Data types for form entry -->
        <!-- Input of simpleType can be any date type -->
        <xf:bind
            nodeset="//cda:value[@cityEHR:elementType = ('#CityEHR:ElementProperty:simpleType','#CityEHR:Property:ElementType:simpleType')]">
            <xf:bind nodeset=".[@xsi:type='xs:date']/@value" type="xs:date"/>
            <xf:bind nodeset=".[@xsi:type='xs:dateTime']/@value" type="xs:dateTime"/>
            <xf:bind nodeset=".[@xsi:type='xs:time']/@value" type="xs:time"/>
            <xf:bind nodeset=".[@xsi:type='xs:string']/@value" type="xs:string"/>
            <xf:bind nodeset=".[@xsi:type='xs:integer']/@value" type="xs:integer"/>
            <xf:bind nodeset=".[@xsi:type='xs:double']/@value" type="xs:double"/>
            <xf:bind nodeset=".[@xsi:type='xs:boolean']/@value" type="xs:boolean"/>
        </xf:bind>

        <!-- Range can only be xs:integer or xs:double -->
        <xf:bind
            nodeset="//cda:value[@cityEHR:elementType = ('#CityEHR:ElementProperty:range','#CityEHR:Property:ElementType:range')]">
            <xf:bind nodeset=".[@xsi:type='xs:integer']/@value" type="xs:integer"/>
            <xf:bind nodeset=".[@xsi:type='xs:double']/@value" type="xs:double"/>
        </xf:bind>

        <!-- Until 2021-10-15 patientMedia was stored in the cda:value element as xs:base64Binary -->
        <!--
        <xf:bind
            nodeset="//cda:value[@cityEHR:elementType = ('#CityEHR:ElementProperty:patientMedia','#CityEHR:Property:ElementType:patientMedia')]"
            type="xs:base64Binary"/>
        -->
        <!-- From 2021-10-15 patientMedia is stored in the cda:value/@value -->
        <xf:bind
            nodeset="//cda:value[@cityEHR:elementType = ('#CityEHR:ElementProperty:patientMedia','#CityEHR:Property:ElementType:patientMedia')]">
            <xf:bind nodeset=".[@xsi:type='xs:base64Binary']/@value" type="xs:base64Binary"/>
        </xf:bind>

        <!-- Media stored in the displayName of media rendered entries (until 2025-05-19.
             Or (from 2025-05-19) in Elements of datatype xs:Name -->
        <xf:bind
            nodeset="//cda:entry[@cityEHR:rendition='#CityEHR:EntryProperty:Image']//cda:value/@displayName"
            type="xs:base64Binary"/>
        <xf:bind nodeset="//cda:value[@xsi:type='xs:Name']/@displayName" type="xs:base64Binary"/>


        <!-- Calculate values designated as calculatedValue or age types. (age added 2018-02-15)
            Context of evaluation is the value attribute.
            So value of local entry/element is found in ../../cda:value[@extension=ElementId]/@value 
            The check on @cityEHR:elementType in the evaluate ensures that the calculation doesn't happen on publish
            (@cityEHR:elementType is changed to simpleTyoe before removing hidden sections, entries, elements but the binding still sticks)
            The check on formStatus ensures that evaluation doesn't happen as the page is loaded, inlcuding during setting of default and pre-filled values.
            From 2018-04-05 this check is made in the binding, rather than the calculate expression (otherwise just calculates '')
            2018-05-14 can have calculated media type values (and check that @cityEHR:calculatedValue is set -->
        <xf:bind
            nodeset="//cda:value[@cityEHR:elementType=('#CityEHR:ElementProperty:calculatedValue','#CityEHR:ElementProperty:age','#CityEHR:ElementProperty:media','#CityEHR:Property:ElementType:calculatedValue','#CityEHR:Property:ElementType:age','#CityEHR:Property:ElementType:media')][exists(@cityEHR:calculatedValue) and @cityEHR:calculatedValue!=''][xxf:instance('cdaControl-instance')/formStatus='ready']/@value"
            calculate="if (xxf:instance('cdaControl-instance')/formStatus='ready' and ../@cityEHR:elementType=('#CityEHR:ElementProperty:calculatedValue','#CityEHR:ElementProperty:age','#CityEHR:ElementProperty:media','#CityEHR:Property:ElementType:calculatedValue','#CityEHR:Property:ElementType:age','#CityEHR:Property:ElementType:media')) then xxf:evaluate(../@cityEHR:calculatedValue) else ''"/>


        <!-- Calculate units designated as calculatedUnit type.
            Get the units of the specified the value in the same entry.
        -->
        <xf:bind nodeset="//cda:value[@cityEHR:calculatedUnit!='']">
            <xf:bind nodeset="@units"
                calculate="xxf:evaluate(concat('../../cda:value[@root=''',../@cityEHR:calculatedUnit,''']/@units'))"
            />
        </xf:bind>

        <!-- Set default values for any form-rendered element that has a default specified.
            This specific value will override defaults already set on enumeratedValue and boolean elements when the form laods.
            The default is set whenever the value of the element is empty, but only when the form is first loaded (uses xxf:default instead of calculate) -->
        <!--
            <xf:bind nodeset="cda:component/cda:structuredBody/cda:component/cda:section/descendant::cda:entry[@cityEHR:rendition!='#CityEHR:EntryProperty:ImageMap' and @cityEHR:initialValue='#CityEHR:EntryProperty:Default']/descendant::cda:value[exists(@cityEHR:defaultValue)][@value='']/@value" xxf:default="xxf:evaluate(../@cityEHR:defaultValue)"/>
        -->
        <!-- Debug
            <xf:bind nodeset="cda:component/cda:structuredBody/cda:component/cda:section/descendant::cda:entry[@cityEHR:rendition!='#CityEHR:EntryProperty:ImageMap' and @cityEHR:initialValue='#CityEHR:EntryProperty:Default']/descendant::cda:value[exists(@cityEHR:defaultValue)][@value='']/@value" calculate="xxf:evaluate('xs:string(''hello'')')"/>
        -->

        <!-- Set visibility of conditional sections 
            If there are no conditions to set visibilty then leave it as it was found (needed to keep hidden sections in place and allow for pre-conditions)
            Note that these bindings will trigger the ev:observer="form-instance" that is used to set the editStatus 
        -->
        <xf:bind nodeset="//cda:sectionX/@cityEHR:visibility"
            calculate="if (exists(../@cityEHR:conditions[.!=''])) then xxf:evaluate(../@cityEHR:conditions) else ."/>

        <!-- Set visibility of conditional entries.
            If there are no conditions to set visibilty then leave it as it was found (needed to allow for pre-conditions)
        -->
        <xf:bind nodeset="//cda:entryX/@cityEHR:visibility"
            calculate="if (exists(../@cityEHR:conditions[.!=''])) then xxf:evaluate(../@cityEHR:conditions) else ."/>
        
        <!-- Set visibility of conditional clusters and elements -->
        <xf:bind
            nodeset="//cda:structuredBody/cda:component/cda:section/descendant::cda:valueX/@cityEHR:visibility"
            calculate="if (exists(../@cityEHR:conditions[.!=''])) then xxf:evaluate(../@cityEHR:conditions) else ''"/>

        <!-- Set visibility of clinical codes (cda:code-1 for now) -->
        <xf:bind nodeset="//cda:code-1/@cityEHR:visibility"
            calculate="if (exists(../@cityEHR:conditions[.!=''])) then xxf:evaluate(../@cityEHR:conditions) else ''"/>


        <!-- Check constraints on elements -->
            <xf:bind
            nodeset="cda:component/cda:structuredBody/cda:component/cda:section/descendant::cda:valueX[@cityEHR:constraints]"
            constraint="xxf:evaluate(../@cityEHR:constraints)"/>

        <!-- Set required values on elements -->
        <!-- Do we need this? 2013-12-04
            <xf:bind nodeset="cda:component/cda:structuredBody/cda:component/cda:section/descendant::cda:value[@cityEHR:required='Required']" required="true()"/>
        -->

        <!-- Pre-filled multiple entries cannot be updated for CRD, CR or R entries.
            The binding is on the component, not the entry so that any new entries added can be updated. -->
        <xf:bind
            nodeset="//cda:component[@cityEHR:CRUD=('#CityEHR:EntryProperty:CRD','#CityEHR:EntryProperty:CR','#CityEHR:EntryProperty:R','#CityEHR:Property:CRUD:CRD','#CityEHR:Property:CRUD:CR','#CityEHR:Property:CRUD:R')]/descendant::cda:value"
            readonly="true()"/>



    </xf:bind>


    <!-- === Queries and submissions to get the cda document 
         These are similar to the ones in notificationModel.xml
         ========================================================= -->

    <xf:instance id="getCDATemplateXQuery-instance"
        src="oxf:/apps/ehr/xquery/getCompositionTemplateXQuery.xml"/>

    <!-- Application defined action to get the composition template.
         Set template query and run submission.
         CDA document is then in form-instance. -->
    <xf:action ev:event="load-composition-template">
        <xxf:variable name="compositionIRI" select="event('compositionIRI')"/>

        <xxf:variable name="storageLocation"
            select="concat('/xmlstore/applications/',xxf:instance('session-parameters-instance')/applicationId,'/systemConfiguration/',xxf:instance('cdaControl-instance')/specialtyId)"/>
        <xf:setvalue ref="xxf:instance('getCDATemplateXQuery-instance')/typeId"
            value="$compositionIRI"/>

        <!-- Load the template CDA to form-instance -->
        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$storageLocation"/>
            <xxf:context name="query" select="xxf:instance('getCDATemplateXQuery-instance')"/>
            <xxf:context name="response" select="xxf:instance('form-instance')"/>
            <xxf:context name="status" select="xxf:instance('cdaControl-instance')/status"/>
        </xf:dispatch>

        <!-- Template loaded successfully -->
        <xf:action if="xxf:instance('cdaControl-instance')/status=''">
            <!-- Set up the dictionary for enumeratedDirectory elements - requires directory-model to be present -->
            <xf:dispatch name="load-directoryElements" target="directory-model">
                <xxf:context name="specialtyIRI"
                    select="xxf:instance('cdaControl-instance')/specialtyIRI"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>


    <!-- Application defined action to load the composition.
         This is used to load the composition for generate-report in exportDataModel
         Parameters are the patientId and the compositionIRI
         CDA composition is then in form-instance. 
    
         The CDA composition may contain pre-filled entries, directory entries, default values and calculated values
    
         -->
    <xf:action ev:event="load-composition">
        <xxf:variable name="patientId" select="event('patientId')"/>
        <xxf:variable name="compositionIRI" select="event('compositionIRI')"/>

        <!-- Set the patientId that is used to get values from the patient record -->
        <xf:setvalue ref="xxf:instance('view-parameters-instance')/patientId" value="$patientId"/>

        <!-- Load composition template for the patient.
             This also calls load-directoryElementsForForm if the submission was successful -->
        <xf:dispatch name="load-composition-template" target="cda-model">
            <xxf:context name="compositionIRI" select="$compositionIRI"/>
        </xf:dispatch>

        <!-- Set pre-filled values -->
        <xf:dispatch name="set-pre-filled-values" target="cda-model"/>

        <!-- Set the default values. ***JC DEBUGGING
             Need to recalculate first to make sure that pre-filled values have stuck -->
        <xf:rebuild model="cda-model"/>
        <xf:dispatch name="set-default-values" target="cda-model"/>

        <!-- Expand out multiple entries where required.
             Done after pre-filled and default values, in case there are calculatedEnumeratedValues which use pre-filled or default entries.
             Any default values in the expanded entry are set during expand-entry -->
        <xf:action>
            <xf:dispatch name="expand-multiple-entries" target="cda-model"/>
        </xf:action>

        <!-- Don't need to evaluate pre-conditions on sections and entries,
             Since this is done for multiple entries in set-pre-filled-values -->

        <!-- Look up all directory entries, in case key value is set as a default, pre-filled or calculated value -->
        <!-- Not defined yet, so don't use directory entries in reports (ie CRUD = L for entry)
        <xf:dispatch name="refresh-directory-entries" target="cda-model"/>
        -->

        <!-- Set default values again, in case any depend on other default values -->
        <xf:dispatch name="set-default-values" target="cda-model"/>

        <!-- Set the status of the cda document to 'ready' so that calculations are activated.
             Then rebuild so that calculation bindings are evaluated -->
        <xf:setvalue ref="xxf:instance('cdaControl-instance')/formStatus" value="'ready'"/>
        <xf:rebuild model="cda-model"/>

    </xf:action>


    <!-- === Setting up the composition based on the stored patient record 
         Pre-filled values, default values and expanded multiple entries 
         ========================================================= -->

    <xf:instance id="getLatestEntrySetXQuery-instance"
        src="oxf:/apps/ehr/xquery/getLatestEntrySetXQuery.xml"/>

    <xf:instance id="latestEntry-instance">
        <eventValue/>
    </xf:instance>
    <xf:instance id="latestEntrySet-instance">
        <eventValue/>
    </xf:instance>


    <!-- Application defined action to set pre-filled values
        Need to handle single and multipleEntry cases differently. 
        The processing must take account of the fact that the information model may have changed since the last entry was recorded.
        
        Iterate through the pre-filled entries
        Get the stored entry and if it exists handle the following cases:
            1) Simple entry
            2) Multiple entry
        
        An observation may include supplementary data sets (as a cda:entryRelationship) for enumeratedClass elements
        So need to prefill any supplementary data sets (whether in single or multiple entries) 
        
        Other entry types (act, encounter, supply, substanceAdministration) may also contain a cda:entryRelationship
        
        EXCEPT for expanded multipleEntry, because the set of entries is fixed from the expansion, so don't need to insert any prefilled entries,
        but do need to set the prefilled values for each entry in the (expanded) multipleEntry.    
    -->
    <xf:action ev:event="set-pre-filled-values">
        <!-- Get the main section (body) of the CDA document for use in processing below.
             This returns a sequence of the top-level sections in the document 
             Note that the form-instance may have a document element of cda:ClinicalDocument or response from a query -->
        <xxf:variable name="cdaBody"
            select="xxf:instance('form-instance')//cda:structuredBody/cda:component/cda:section"/>

        <!-- Get pre-filled entries and latest values from xmlstore.
             Note that pre-filled entries use the extension, not the root of the entry to get the stored value
             If there are proxy entries for the same entry on the form, then there will be multiple extensions returned
             Only want one of each, so use distinct-values to get list of entryIRI 
             Also note that the prefilledEntryIRISet is only for entries with no evaluation context 
             Stored entries for other pre-filled entries (with an evaluation context) are found with individual queries (below) -->
        <xxf:variable name="prefilledEntrySet"
            select="$cdaBody/descendant::cda:entry[@cityEHR:initialValue=('#CityEHR:EntryProperty:Pre-filled','#CityEHR:EntryProperty:DistinctValues','#CityEHR:EntryProperty:AllValues','#CityEHR:Property:InitialValue:Pre-filled','#CityEHR:Property:InitialValue:DistinctValues','#CityEHR:Property:InitialValue:AllValues')]"/>
        <xxf:variable name="prefilledEntryIRISet"
            select="distinct-values(for $entry in $prefilledEntrySet return $entry[not(@cityEHR:evaluationContext)]/descendant::cda:id[1]/@extension)"/>

        <!-- Get the latestEntrySet-instance -->
        <xf:dispatch name="get-latestEntrySet" target="cda-model">
            <xxf:context name="entryIRISet" select="$prefilledEntryIRISet"/>
            <xxf:context name="evaluationContext" select="''"/>
            <xxf:context name="latestEntryInstance" select="xxf:instance('latestEntrySet-instance')"
            />
        </xf:dispatch>

        <!-- Iterate through pre-filled entries.
             This must include all entries (even where @extension is repeated for different @root) -->
        <xf:action if="xxf:instance('cdaControl-instance')/status = ''">
            <xf:action xxf:iterate="$prefilledEntrySet">
                <xxf:variable name="prefilledEntry" select="."/>
                <xxf:variable name="prefilledEntryIRI"
                    select="$prefilledEntry/descendant::cda:id[1]/@extension"/>

                <xxf:variable name="evaluationContext"
                    select="if (exists($prefilledEntry/@cityEHR:evaluationContext)) then $prefilledEntry/@cityEHR:evaluationContext else ''"/>

                <!-- If the entry has an evaluation context, 
                     then need to run an individual query to get its stored values.
                     The stored entries are placed in latestEntry-instance (as opposed to latestEntrySet-instance)
                 -->
                <xf:action if="$evaluationContext!=''">

                    <xf:dispatch name="get-latestEntrySet" target="cda-model">
                        <xxf:context name="entryIRISet" select="$prefilledEntryIRI"/>
                        <xxf:context name="evaluationContext" select="$evaluationContext"/>
                        <xxf:context name="latestEntryInstance"
                            select="xxf:instance('latestEntry-instance')"/>
                    </xf:dispatch>

                </xf:action>

                <!-- Now set the entry as returned from the query.
                     Need to be careful here, since the information model for the entry may have changed since the last values were recorded.
                     Need to step through the values in the current form-instance, rather than replacing the whole entry.
                
                     There are two cases to consider:
                      1) Simple entry
                      2) Multiple entry (which can repeat simple or enumerated class entries and may also be expanded)
                  -->

                <!-- The storedEntry is the most recently recorded instance of the entry.
                     These are returned in effectiveTime order, with most recent first.
                     The fullStoredEntrySet contains all recorded values
                     Use the the latestEntrySet-instance or latestEntry-instance-->
                <xxf:variable name="storedEntryInstance"
                    select="if ($evaluationContext!='') then xxf:instance('latestEntry-instance') else xxf:instance('latestEntrySet-instance')"/>
                <xxf:variable name="fullStoredEntrySet"
                    select="$storedEntryInstance/cda:entry[descendant::cda:id[1]/@extension=$prefilledEntryIRI]"/>

                <!-- If initialValue is DistinctValues or AllValues, then keep all fullStoredEntrySet, otherwise just need the first entry -->
                <xxf:variable name="pre-fillType" select="$prefilledEntry/@cityEHR:initialValue"/>
                <xxf:variable name="storedEntrySet"
                    select="if ($pre-fillType=('#CityEHR:EntryProperty:DistinctValues','#CityEHR:Property:InitialValue:DistinctValues','#CityEHR:EntryProperty:AllValues','#CityEHR:Property:InitialValue:AllValues')) then $fullStoredEntrySet else $fullStoredEntrySet[1]"/>

                <!-- If there is a stored entry value, then set in the pre-filled entry. -->
                <xf:action if="exists($storedEntrySet)">

                    <xf:dispatch name="set-pre-filled-entry" target="cda-model">
                        <xxf:context name="prefilledEntry" select="$prefilledEntry"/>
                        <xxf:context name="pre-fillType" select="$pre-fillType"/>
                        <xxf:context name="storedEntrySet" select="$storedEntrySet"/>
                    </xf:dispatch>

                </xf:action>

                <!-- Or if no pre-filled value then use the default.
                 But only for entries in the main body of the document.
                 For entries in the alwaysHidden section(s) then these will be prefilled again if the document is reloaded.
                 (Note that the template entry for pre-filled multiple entries has already been set to #CityEHR:Property:InitialValue:Default above
              -->
                <xf:action
                    if="not(exists($storedEntrySet)) and not(exists($prefilledEntry/ancestor::cda:section[@cityEHR:visibility='alwaysHidden']))">
                    <xf:setvalue ref="$prefilledEntry/@cityEHR:initialValue"
                        value="'#CityEHR:Property:InitialValue:Default'"/>
                </xf:action>
            </xf:action>
        </xf:action>
    </xf:action>


    <!-- Application defined action to get latest (most recent) ebtries from the stored record.
         The set of one or more entryIRIs is passed as entryIRISet
         Used to get the single latestEntry-instance or the latestEntrySet-instance
         Which are passed as the return parameter latestEntryInstance
     -->
    <xf:action ev:event="get-latestEntrySet">
        <xxf:variable name="entryIRISet" select="event('entryIRISet')"/>
        <xxf:variable name="evaluationContext" select="event('evaluationContext')"/>
        <xxf:variable name="latestEntryInstance" select="event('latestEntryInstance')"/>

        <!-- Set patientRecordLocation based on applicationId and patientId -->
        <xxf:variable name="applicationId"
            select="xxf:instance('session-parameters-instance')/applicationId"/>
        <xxf:variable name="patientId"
            select="xxf:instance('session-parameters-instance')/patientId"/>
        <xxf:variable name="patientRecordLocation"
            select="concat('/xmlstore/applications/',$applicationId,'/records/',$patientId)"/>

        <!-- Get set of stored entries for all entryIRI where the entry has no evaluation context.
             This allows a single query to get all such values and place them in latestEntrySet-instance -->
        <xf:setvalue ref="xxf:instance('getLatestEntrySetXQuery-instance')/entryIRISet"
            value="string-join($entryIRISet,''',''')"/>
        <xf:setvalue ref="xxf:instance('getLatestEntrySetXQuery-instance')/evaluationContext"
            value="if (exists($evaluationContext)) then $evaluationContext else ''"/>

        <!-- Return entries to latestEntryInstance -->
        <xf:dispatch name="dal-query" target="databaseAccessLayer-model">
            <xxf:context name="system" select="'ehr'"/>
            <xxf:context name="storageLocation" select="$patientRecordLocation"/>
            <xxf:context name="query" select="xxf:instance('getLatestEntrySetXQuery-instance')"/>
            <xxf:context name="sortOrder" select="'descending'"/>
            <xxf:context name="response" select="$latestEntryInstance"/>
            <xxf:context name="status" select="xxf:instance('cdaControl-instance')/status"/>
        </xf:dispatch>

        <!-- Check if there was an error -->
        <xf:action if="not(xxf:instance('cdaControl-instance')/status = '')">
            <xf:setvalue ref="xxf:instance('view-parameters-instance')/systemError"
                value="xxf:instance('view-parameters-instance')/systemErrorList/systemError[@type='failedGetLatestEntry']"
            />
        </xf:action>

    </xf:action>


    <!-- Application defined action to set a prefilled entry. 
         prefilledEntry is the cda:entry or cda:component (contains cda:observation, cda:act, etc)
         storedEntrySet is the set of stored entries (cda:entry) in the patient record with the same entryIRI.
     -->
    <xf:action ev:event="set-pre-filled-entry">
        <xxf:variable name="prefilledEntry" select="event('prefilledEntry')"/>
        <xxf:variable name="pre-fillType" select="event('pre-fillType')"/>
        <xxf:variable name="storedEntrySet" select="event('storedEntrySet')"/>

        <!-- CRUD Property value -->
        <xxf:variable name="entryCRUD"
            select="if (exists($prefilledEntry/@cityEHR:CRUD)) then $prefilledEntry/@cityEHR:CRUD else ''"/>
        <xxf:variable name="entryCRUDValue" select="tokenize($entryCRUD, ':')[position() = last()]"/>

        <!-- Get the stored entry components - may be in a ME, which may be sorted.
             The storedEntryComponentSet is a set of cda:entry and cda:component, each containing cda:observation, cda:act, etc -->
        <xxf:variable name="storedEntryComponentSet"
            select="$storedEntrySet[not(cda:organizer)] | $storedEntrySet/cda:organizer[@classCode='MultipleEntry']/cda:component[2]/cda:organizer/cda:component"/>

        <!-- Get the sorted entry set.
             The sort criteria are found on the pre-filled entry.
             Note that the sort criteria use the @root to identify the sort criteria element -->
        <xxf:variable name="sortOrder"
            select="if ($prefilledEntry/@cityEHR:SortOrder = 'Ascending') then 'ascending' else if ($prefilledEntry/@cityEHR:SortOrder = 'Descending') then 'descending' else 'unsorted'"/>
        <xxf:variable name="sortCriteria"
            select="if (exists($prefilledEntry/@cityEHR:sortCriteria) and exists($prefilledEntry/descendant::cda:value[not(child::*)][@root=$prefilledEntry/@cityEHR:sortCriteria]) ) then $prefilledEntry/@cityEHR:sortCriteria else ($prefilledEntry/descendant::cda:value[@root])[1]/@root"/>

        <!-- The sorted entry set applies the sort order to the full set.
             But xxf:sort throws an exception if the sort criteria (second argument) dosn't exist on any of the elements to be sorted.
             So make sure only sortable observations are included in first argument -->
        <!--
                <xxf:variable name="sortableObservationSet"
                    select="if (count($storedObservationSet) gt 1) then $storedObservationSet[1] else $storedObservationSet[descendant::cda:value[@root=$sortCriteria]/@value]"/>
                -->

        <xxf:variable name="sortableEntryComponentSet"
            select="$storedEntryComponentSet[descendant::cda:value[@root=$sortCriteria][@value]]"/>

        <!--
                <xxf:variable name="sortedStoredObservationSet"
                    select="if ($sortOrder!='unsorted') then xxf:sort($storedObservationSet,descendant::cda:value[not(child::*)][@root=$sortCriteria]/@value,'text', $sortOrder) else $storedObservationSet"/>
                -->
        <xxf:variable name="sortedStoredEntryComponentSet"
            select="if ($sortOrder!='unsorted' and exists($sortableEntryComponentSet)) then xxf:sort($sortableEntryComponentSet,descendant::cda:value[@root=$sortCriteria]/@value[1],'text', $sortOrder) else $storedEntryComponentSet"/>

        <!-- 1) Simple entry.
                    Iterate through elements of the prefilledEntry, setting values from the storedEntry.
                    Note that its possible the storedEntry is a multiple entry
                    (Need to cater for clusters here (from 10/03/2014) - make sure that clusterLocation in storedElement matches pre-filled element.)
                    From 2017-09-29 clusters only used for organisation. not the context of a value. So the entry/element value is set wherever it appears in a cluster.
                    This also means that an entry can only ntain one element of a particular elementIRI -->
        <xf:action if="not(exists($prefilledEntry/cda:organizer))">

            <!-- The stored observation is the first one in the sorted set.
                 There will only be more than one observation in this set if the simple entry is being prefilled from DistinctValues of a multiple entry -->
            <xxf:variable name="storedEntry" select="$sortedStoredEntryComponentSet[1]"/>

            <!-- Get the set of values to be pre-filled
                 If the Entry is a directory look-up then just set value of the key element.
                 Otherwise set all the values -->

            <xxf:variable name="preFilledValues"
                select="if ($entryCRUDValue='L') then ($prefilledEntry//cda:value[@root=$sortCriteria]) else $prefilledEntry//cda:value[exists(@value)]"/>

            <!-- Iterate through the values to be pre-filled -->
            <xf:action xxf:iterate="$preFilledValues">
                <xxf:variable name="prefilledElement" select="."/>

                <!-- clusterLocation no longer needed 2017-09-29 -->
                <!-- 
                        <xxf:variable name="clusterLocation" select="string-join($prefilledElement/ancestor::cda:value/@extension,'/')"/>
                        <xxf:variable name="storedElement"
                            select="$storedObservation/descendant::cda:value[@extension=$prefilledElement/@extension][string-join(./ancestor::cda:value/@extension,'/')=$clusterLocation][1]"/>
                        -->
                <xxf:variable name="storedElement"
                    select="$storedEntry//cda:value[@extension=$prefilledElement/@extension][1]"/>

                <xf:action if="exists($storedElement)">

                    <!-- If this element is an enumeratedValue element.
                         The stored value must exactly match a value in the model
                         Otherwise leave blank -->
                    <xf:action
                        if="$prefilledElement/@cityEHR:elementType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:calculatedEnumeratedValue')">

                        <xxf:variable name="prefilledElementIRI"
                            select="$prefilledElement/@extension"/>

                        <!-- Get the element from the data dictionary (need to match the root attribute in the data dictionary) -->
                        <xxf:variable name="dictionaryElement"
                            select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$prefilledElementIRI]"/>
                        <xxf:variable name="dictionaryElementType"
                            select="$dictionaryElement/@cityEHR:elementType"/>

                        <!-- Dictionary data - matches the stored value -->
                        <xxf:variable name="dictionaryData"
                            select="if ($dictionaryElementType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:enumeratedCalculatedValue')) then $dictionaryElement/iso-13606:data[@value=$storedElement/@value] else ()"/>

                        <!-- If the stored value is still in the information model, then set the prefilled value -->
                        <xf:action if="exists($dictionaryData)">
                            <xf:setvalue ref="$prefilledElement/@value"
                                value="$dictionaryData/@value"/>
                            <xf:setvalue ref="$prefilledElement/@displayName"
                                value="$dictionaryData/@displayName"/>
                            <xf:setvalue ref="$prefilledElement/@code" value="$dictionaryData/@code"
                            />
                        </xf:action>

                    </xf:action>

                    <!-- If this element is an enumeratedClass element.
                         The stored value must exactly match a class in the model
                         Otherwise leave blank-->
                    <xf:action
                        if="$prefilledElement/@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedClass'">

                        <xf:dispatch name="set-pre-filled-enumeratedClass" target="cda-model">
                            <xxf:context name="prefilledEntry" select="$prefilledEntry"/>
                            <xxf:context name="storedEntry" select="$storedEntry"/>
                            <xxf:context name="prefilledElement" select="$prefilledElement"/>
                            <xxf:context name="storedElement" select="$storedElement"/>
                        </xf:dispatch>

                    </xf:action>

                    <!-- Any other elementType, just set the pre-filled value -->
                    <xf:action
                        if="not($prefilledElement/@cityEHR:elementType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:calculatedEnumeratedValue','#CityEHR:ElementProperty:enumeratedClass'))">

                        <xf:setvalue ref="$prefilledElement/@value" value="$storedElement/@value"/>
                        <xf:setvalue ref="$prefilledElement/@displayName"
                            value="$storedElement/@displayName"/>
                        <xf:setvalue ref="$prefilledElement/@code" value="$storedElement/@code"/>

                    </xf:action>
                </xf:action>

            </xf:action>
        </xf:action>


        <!-- 2) Multiple entry
                Can either use the storedEntry or get storedDistinctEntries (if Pre-filled or DistinctValues)
                Iterate through multiple entries of the storedEntry
                Once pre-fllled, the template entry needs to be set to ? -->
        <xf:action if="exists($prefilledEntry/cda:organizer[@classCode='MultipleEntry'])">

            <xxf:variable name="entryTemplate"
                select="$prefilledEntry/cda:organizer/cda:component[1]"/>

            <!-- Get parameters for expanded multipleEntry.
                 The expanded element is the first one with #CityEHR:ElementProperty:Expanded or #CityEHR:ElementProperty:Full -->
            <xxf:variable name="expandedMultipleEntry"
                select="if ($prefilledEntry/@cityEHR:Scope=('#CityEHR:EntryProperty:Expanded','#CityEHR:EntryProperty:Full','#CityEHR:Property:Scope:Full')) then 'true' else 'false'"/>
            <xxf:variable name="expandedElementIRI"
                select="$entryTemplate/descendant::cda:value[@cityEHR:Scope=('#CityEHR:ElementProperty:Expanded','#CityEHR:ElementProperty:Full')][1]/@root"/>

            <!-- Get distinct values for stored entry.
                 For multiple entries the observation elements are within cda:component in the second cda:component of the entry
                 pre-fillType is #CityEHR:EntryProperty:Pre-filled or #CityEHR:EntryProperty:DistinctValues 
                 For distinct values get all previous entries (storedEntry is just most recent and is used for pre-Filled) -->
            <xxf:variable name="storedEntryKeys"
                select="distinct-values($sortedStoredEntryComponentSet/string-join(descendant::cda:value/@value,''))"/>
            <xxf:variable name="distinctStoredEntryComponentSet"
                select="for $k in $storedEntryKeys return $sortedStoredEntryComponentSet[string-join(descendant::cda:value/@value,'') = $k][1]"/>

            <!-- Debugging -->
            <!--
                    <xf:action if="$pre-fillType = ('#CityEHR:EntryProperty:AllValues','#CityEHR:Property:InitialValue:AllValues')">
                        <xf:message ref="concat(count($distinctStoredObservations),' / ',count($sortedStoredObservationSet))"/>
                    </xf:action>
                    -->

            <!-- Insert an entry for each instance of an entry found in the stored entry set.
                 For DistinctValues then use $distinctStoredEntryComponentSet, otherwise $sortedStoredEntryComponentSet 
                 OR if this is an expanded multipleEntry then just set the values of the entry that has already been inserted (by expand-multiple-entries)
                 The storedEntry instance is a cda:component that contains a cda:observation  -->

            <xf:action
                xxf:iterate="if ($pre-fillType=('#CityEHR:EntryProperty:DistinctValues','#CityEHR:Property:InitialValue:DistinctValues')) then $distinctStoredEntryComponentSet else $sortedStoredEntryComponentSet">

                <xxf:variable name="storedEntryComponent" select="."/>

                <!-- If the entry has pre-conditions then evaluate them.
                     If conditions are true then insert the entry, otherwise don't.
                     Pre-conditions are evaluated relative to the first child of the storedEntryComponent.
                     This allows for the context of the expression which uses the elements values relative to the specific entry, if necessary 
                 -->
                <xxf:variable name="preConditions" select="$prefilledEntry/@cityEHR:preConditions"/>
                <xxf:variable name="preConditionsEvaluation"
                    context="$storedEntryComponent//cda:id[1]"
                    select="if (exists($preConditions)) then xxf:evaluate($preConditions) else 'true'"/>


                <!-- Insert the entryTemplate (or find the entry already inserted by expand-multiple-entries) and set values, but only if conditions allow -->
                <xf:action if="$preConditionsEvaluation">
                    <xf:action if="$expandedMultipleEntry='false'">
                        <xf:insert
                            context="$prefilledEntry/cda:organizer/cda:component[2]/cda:organizer"
                            nodeset="cda:component" position="last()" origin="$entryTemplate"/>
                    </xf:action>

                    <!-- Set values in the entryTemplate after inserting it.
                                 First need to get the inserted entry 
                                 This entry should be at the last() position in the entry set if it has just been inserted,
                                 or is the entry that has the same value of the expandedElement as the storedEntryComponent. 
                            -->
                    <xxf:variable name="expandedElementValue"
                        select="$storedEntryComponent/descendant::cda:value[@root=$expandedElementIRI][1]/@value"/>
                    <xxf:variable name="insertedComponent"
                        select="if ($expandedMultipleEntry='false') then $prefilledEntry/cda:organizer/cda:component[2]/cda:organizer/cda:component[last()] else $prefilledEntry/cda:organizer/cda:component[2]/cda:organizer/cda:component[descendant::cda:value[@root=$expandedElementIRI][1]/@value=$expandedElementValue]"/>

                    <!-- Check here that the insertedComponent exists - should do, but just in case -->
                    <xf:action if="exists($insertedComponent)">
                        <!-- Set the CRUD attribute on the inserted entry (which is a cda:component).
                                     Since these are pre-filled entries, we need to consider whether the entry can be updated.
                                     If $entryCRUDValue contains 'U' then it can be updated (edited) and also deleted.
                                     If $entryCRUDValue does not contain 'U' then the pre-filled entries are read-only.
                                     -->
                        <xf:setvalue ref="$insertedComponent/@cityEHR:CRUD"
                            value="if (contains($entryCRUDValue,'U')) then '#CityEHR:Property:CRUD:U' else '#CityEHR:Property:CRUD:R'"/>
                        <!-- Set the origin attribute on the inserted entry -->
                        <xf:setvalue ref="$insertedComponent/descendant::cda:id[1]/@cityEHR:origin"
                            value="''"/>

                        <!-- Set the pre-filled values for the inserted component.
                                 This is done with a recursive call to set-pre-filled-entry -->
                        <xf:dispatch name="set-pre-filled-entry" target="cda-model">
                            <xxf:context name="prefilledEntry" select="$insertedComponent"/>
                            <xxf:context name="pre-fillType" select="$pre-fillType"/>
                            <xxf:context name="storedEntrySet" select="$storedEntryComponent"/>
                        </xf:dispatch>


                        <!--
                            <xf:action
                                xxf:iterate="$insertedComponent/cda:observation/descendant::cda:value[exists(@value)]">
                                <xxf:variable name="prefilledElement" select="."/>
                                <xxf:variable name="storedElement"
                                    select="$storedEntry/descendant::cda:value[@extension=$prefilledElement/@extension][1]"/>
                                <xf:action if="exists($storedElement)">
                                    <xf:setvalue ref="$prefilledElement/@value"
                                        value="$storedElement/@value"/>
                                    <xf:setvalue ref="$prefilledElement/@displayName"
                                        value="$storedElement/@displayName"/>
                                    <xf:setvalue ref="$prefilledElement/@code"
                                        value="$storedElement/@code"/>
                                </xf:action>
                            </xf:action>
-->
                    </xf:action>
                    <!-- End of handing inserted entry -->

                </xf:action>
                <!-- End of processing for valid preConditions -->

            </xf:action>
            <!-- End iteration through stored entries -->



            <!-- Reset the initialValue property so that template entry uses default values -->
            <xf:setvalue ref="$prefilledEntry/@cityEHR:initialValue"
                value="'#CityEHR:Property:InitialValue:Default'"/>


        </xf:action>
        <!-- End of multipleEntry -->


    </xf:action>


    <!-- Application defined action to set a prefilled enumeratedClass element. 
         prefilledEntry is the cda:entry or cda:component (contains cda:observation, cda:act, etc)
         Includes setting the SDS, if there is one.
     -->
    <xf:action ev:event="set-pre-filled-enumeratedClass">
        <xxf:variable name="prefilledEntry" select="event('prefilledEntry')"/>
        <xxf:variable name="storedEntry" select="event('storedEntry')"/>
        <xxf:variable name="prefilledElement" select="event('prefilledElement')"/>
        <xxf:variable name="storedElement" select="event('storedElement')"/>

        <xxf:variable name="prefilledElementIRI" select="$prefilledElement/@root"/>

        <!-- Get the element from the class dictionary, matching the pre-filled displayName.
             To do this, first get the class element from the specialty dictionary.
             The class element defines the class (@code) and entry node (@value) for the class dictionary
             Then query the class dictionary to get the matching class node -->
        <xxf:variable name="dictionaryElement"
            select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$prefilledElementIRI]/iso-13606:data[1]"/>
        <xxf:variable name="classCode" select="$dictionaryElement/@code"/>
        <xxf:variable name="classElement"
            select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$classCode][@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedClass']/iso-13606:data[1]"/>
        <xxf:variable name="entryNode" select="$classElement/@value"/>


        <!-- Run query to get element for node in class dictionary - there should be one hit.
             Results are returned in enumeratedClass-instance -->
        <xf:dispatch name="get-enumeratedClassElements" target="classDictionary-model">
            <xxf:context name="searchValue" select="$storedElement/@displayName"/>
            <xxf:context name="classCode" select="$classCode"/>
            <xxf:context name="entryNode" select="$entryNode"/>
            <xxf:context name="elementScope" select="''"/>
        </xf:dispatch>

        <!-- Only set the prefilled element if there is a single search hit on the displayName -->
        <xf:action if="count(xxf:instance('enumeratedClass-instance')/iso-13606:data)=1">
            <xxf:variable name="classDictionaryElement"
                select="xxf:instance('enumeratedClass-instance')/iso-13606:data"/>

            <!-- Set basic element attributes -->
            <xf:setvalue ref="$prefilledElement/@value" value="$classDictionaryElement/@value"/>
            <xf:setvalue ref="$prefilledElement/@displayName"
                value="$classDictionaryElement/@displayName"/>
            <xf:setvalue ref="$prefilledElement/@code" value="$classDictionaryElement/@code"/>

            <!-- Set the element value to be displayName so that the input for enumeratedClass selection is primed -->
            <xf:setvalue ref="$prefilledElement" value="$classDictionaryElement/@displayName"/>

            <!-- The SDS must be in the dictionary-instance -->
            <xxf:variable name="prefilledSDSIRI"
                select="$classDictionaryElement/@cityEHR:suppDataSet"/>
            <xf:setvalue ref="$prefilledElement/@cityEHR:suppDataSet" value="$prefilledSDSIRI"/>

            <!-- Get SDS from the data dictionary and insert it, then set its origin.
                 The SDS is a component containing the cda:entry for the SDS.
                 This is found in the dictionary-instance -->
            <xf:action if="$prefilledSDSIRI!=''">
                <!-- Get the SDS -->
                <xxf:variable name="prefilledSuppDataSet"
                    select="xxf:instance('dictionary-instance')/iso-13606:entryCollection/iso-13606:entry/cda:component/cda:observation[cda:id/@extension=$prefilledSDSIRI]"/>

                <!-- If the SDS exists -->
                <xf:action if="exists($prefilledSuppDataSet)">
                    <!-- Insert the template entryRelationship into the prefilledEntry (cda:entry)
                         Allow for this to contain cda:observation, cda:act, etc  -->
                    <xf:insert context="$prefilledEntry/*" nodeset="*"
                        origin="xxf:instance('cdaControl-instance')/cda:entryRelationship"
                        at="last()" position="after"/>

                    <!-- Set the origin of the new entryRelationship -->
                    <xxf:variable name="suppDataSet"
                        select="$prefilledEntry/*/cda:entryRelationship[@cityEHR:origin = ''][1]"/>
                    <xf:setvalue ref="$suppDataSet/@cityEHR:origin" value="$prefilledElementIRI"/>

                    <!-- Insert the new SDS entry (cda:observation) -->
                    <xf:insert context="$suppDataSet" nodeset="*" origin="$prefilledSuppDataSet"/>

                    <!-- Get the stored SDS from the storedEntry -->
                    <xxf:variable name="storedSuppDataSet"
                        select="$storedEntry//cda:entryRelationship[@cityEHR:origin = $prefilledElementIRI][1]"/>

                    <!-- Set the prefilled elements in the SDS -->
                    <xf:dispatch name="set-pre-filled-entry" target="cda-model">
                        <xxf:context name="prefilledEntry" select="$suppDataSet"/>
                        <xxf:context name="pre-fillType" select="''"/>
                        <xxf:context name="storedEntrySet" select="$storedSuppDataSet"/>
                    </xf:dispatch>

                </xf:action>
            </xf:action>

        </xf:action>
    </xf:action>

    <!-- Application defined action to set the external entries referenced in a letter template. 
         Finds the entries referenced in the letter templae that are not in the CDA instance.
         Gets the most recent entry and inserts in the #CityEHR:ExternalReferences section of the CDA instance
     -->
    <xf:action ev:event="set-externalReferencesEntries">
        <xxf:variable name="cdaInstance" select="event('cdaInstance')"/>
        <xxf:variable name="letterTemplate" select="event('letterTemplate')"/>

        <!-- Get list of external entries from the letterTemplate
             These are entries that are referenced in the template but are not in the cdaInstance
             Get the entries referenced in the letter template
             Then the entries in the CDA instance (including entries in the hidden #CityEHR:ExternalVariables section)
             The external entries are the ones that are referenced in the template, but are not in the CDA -->
        <xxf:variable name="letterTemplateEntries"
            select="distinct-values($letterTemplate/letterTemplateVariables/variable[starts-with(@ref,'#ISO-13606:Entry')]/tokenize(@ref,'/')[1])"/>
        <xxf:variable name="cdaInstanceEntries"
            select="distinct-values($cdaInstance//cda:id[starts-with(@extension,'#ISO-13606:Entry')]/@extension)"/>
        <xxf:variable name="externalEntries"
            select="$letterTemplateEntries[not(.=$cdaInstanceEntries)]"/>

        <!-- Load the external entries from the patient record -->
        <xf:dispatch name="get-latestEntrySet" target="cda-model">
            <xxf:context name="entryIRISet" select="$externalEntries"/>
            <xxf:context name="evaluationContext" select="''"/>
            <xxf:context name="latestEntryInstance" select="xxf:instance('latestEntrySet-instance')"
            />
        </xf:dispatch>

        <!-- Clear the #CityEHR:ExternalReferences section -->
        <xxf:variable name="externalReferencesSection"
            select="$cdaInstance//cda:section[cda:id/@extension='#CityEHR:ExternalReferences']"/>
        <xf:delete nodeset="$externalReferencesSection/cda:entry"/>

        <!-- Insert externally referenced entries -->
        <xf:action xxf:iterate="$externalEntries">
            <xxf:variable name="externalEntryIRI" select="."/>

            <!-- Get the stored entry from the latestEkntrySet instance.
                 The entries are returned in effectiveTime order, with the most recent first.
                 So just need the first one to get the current entry value -->
            <xxf:variable name="storedEntry"
                select="xxf:instance('latestEntrySet-instance')/cda:entry[descendant::cda:id[1]/@extension=$externalEntryIRI][1]"/>

            <!-- Insert the entry in the externalReferencesSection -->
            <xf:insert context="$externalReferencesSection" nodeset="*" origin="$storedEntry"
                at="last()" position="after"/>
        </xf:action>

    </xf:action>

    <!-- Application defined action to set default values. 
        This is only done when a new form is loaded (not a saved form)
        These are on entries with @cityEHR:initialValue='#CityEHR:Entry:InitialValue:Default', so need to iterate through all of these. 
        This sets the default value of some types of element.
        Or if a default value has been specified in the model then this is calculated -->
    <xf:action ev:event="set-default-values">
        <!-- Get the main section (body) of the CDA document for use in processing below -->
        <xxf:variable name="cdaBody"
            select="xxf:instance('form-instance')//cda:structuredBody/cda:component/cda:section"/>

        <xf:action
            xxf:iterate="$cdaBody/descendant::cda:entry[@cityEHR:initialValue=('#CityEHR:EntryProperty:Default','#CityEHR:Property:InitialValue:Default')]">
            <xxf:variable name="entry" select="."/>

            <!-- When the simple entry is not rendered as an image map or the template entry of any multiple entry.
                From 2018-05-07 simple entries (not image map) or template for multiple entries, but not in the prefilled entries of multiple entry
                Note that this will set default values in the template for multiple entries (which is what we want)
                Simple entries will be of the form cda:entry/cda:observation/cda:value (assume that other types of entry cannot be rendered as image maps)
                Whereas multipleEntry is of the form cda:entry/cda:organizer/cda:component/cda:observation/cda:value
                
                From 2025-03-08 default values are set on entries rendered as imageMap, as required by SVG image maps
            -->
            <!--
            <xxf:variable name="entryForDefault"
                select="$entry[not(@cityEHR:rendition=('#CityEHR:EntryProperty:ImageMap','#CityEHR:Property:Rendition:ImageMap'))]/cda:observation |
                $entry[not(@cityEHR:rendition=('#CityEHR:EntryProperty:ImageMap','#CityEHR:Property:Rendition:ImageMap'))]/cda:act |
                        $entry/cda:organizer/cda:component[1]"/>
            -->

            <xxf:variable name="entryForDefault"
                select="$entry/cda:observation |
                $entry/cda:act |
                $entry/cda:organizer/cda:component[1]"/>

            <xf:action if="exists($entryForDefault)">
                <xf:dispatch name="set-entry-default-values" target="cda-model">
                    <xxf:context name="entry" select="$entryForDefault"/>
                </xf:dispatch>
            </xf:action>

            <!-- Set default values for simple entries rendered as image maps (all element values default to 0).
                Note that multiple entries displayed as image maps must not get set to 0.
                Simple entries will be of the form cda:entry/cda:observation/cda:value (assume that other types of entry cannot be rendered as image maps)
                Whereas multipleEntry is of the form cda:entry/cda:organizer/cda:component/cda:observation/cda:value -->
            <!-- 2025-03-08 - not needed for SVG image maps -->
            <!--
            <xf:action
                xxf:iterate="$entry[@cityEHR:rendition=('#CityEHR:EntryProperty:ImageMap','#CityEHR:Property:Rendition:ImageMap')]/cda:observation/descendant::cda:value[@value='']">
                <xf:setvalue ref="./@value" value="'0'"/>
            </xf:action>
            -->

            <!-- Multiple entry that does not have any prefilled values.
                There is no entry in the second organizer yet, so need to add one from the template (which will have had default values set above)
                This happens for default entries and for pre-filled entries that had no stored entry found -->
            <!-- Decided not to do this yet 17/01/2014
                <xf:action if="exists($entry/cda:organizer[@classCode='MultipleEntry'])">
                
                </xf:action>
            -->
        </xf:action>

        <!-- Set default value of false() for any xs:boolean values that are not set 
            (i.e. not prefilled and not explicitly set as a default value)
            This also finds xs:booelan values in the templates of multiple entries -->
        <xf:action xxf:iterate="$cdaBody/descendant::cda:value[@value=''][@xsi:type='xs:boolean']">
            <xxf:variable name="element" select="."/>
            <xf:setvalue ref="$element/@value" value="false()"/>
        </xf:action>

    </xf:action>


    <!-- Application defined action to set default values for an entry.
         The entry (cda:observation, cda:act, etc or cda:component for a multiple entry) is passed as a parameter 
         Called from set-default-values and when a new entry is added to a multipleEntry (in CDA2XForm-Module.xsl)
    -->
    <xf:action ev:event="set-entry-default-values">
        <xxf:variable name="entry" select="event('entry')"/>

        <!-- Iterate through empty values that have a default specified or are xs:boolean -->
        <!--
        <xf:action xxf:iterate="$entry/descendant::cda:value[@value=''][@cityEHR:defaultValue!='' or @xsi:type='xs:boolean']">
        -->
        <!-- 2019-08-29 - just setting empty values meant that values only got set the first time set-default-values was invoked
             Iterate through values that have a default specified or are xs:boolean -->
        <xf:action
            xxf:iterate="$entry/descendant::cda:value[@cityEHR:defaultValue!='' or @xsi:type='xs:boolean']">

            <xxf:variable name="element" select="."/>
            <!--
            <xf:message ref="$element/@root"/>
-->

            <!-- Element has a default value specified then use xxf:evaluate to set it               
                 Context of evaluation must be the value attribute.
                 So value of local entry/element is found in ../../cda:value[@extension=ElementId]/@value
                 This means that setvalue must be done with ref=$element/@value so that the evaluation context is correct
                 If there is no default value specified and the type is xs:boolean, then set to false()
                 The defaultValue variable can then be set for ongoing processing
            -->
            <xxf:variable name="defaultValue" select="$element/@value"/>
            <xf:setvalue ref="$defaultValue"
                value="if ($element/@cityEHR:defaultValue!='') then xxf:evaluate($element/@cityEHR:defaultValue) else if ($element/@xsi:type='xs:boolean') then false() else ''"/>
            <!--
            <xf:message ref="concat($element/@root,' / ',$defaultValue)"/>
-->
            <!-- If the element is an enumeratedValue, enumeratedCalculatedValue, enumeratedClass or enumeratedDirectory 
                then need to check that the value set is allowable
                and also need to set the displayName (and code).
                The checks need to be made against the root element in the dictionary/directory
            -->

            <!-- enumeratedValue - data dictionary holds a list of element values -->
            <xf:action if="$element/@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedValue'">
                <xxf:variable name="elementIRI" select="$element/@root"/>
                <xxf:variable name="dictionaryElement"
                    select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$elementIRI]/iso-13606:data[@value=$defaultValue]"/>

                <xf:setvalue ref="$element/@value"
                    value="if (exists($dictionaryElement)) then . else ''"/>
                <xf:setvalue ref="$element/@displayName"
                    value="if (exists($dictionaryElement)) then $dictionaryElement/@displayName else ''"/>
                <xf:setvalue ref="$element/@code"
                    value="if (exists($dictionaryElement)) then  $dictionaryElement/@code else ''"/>
            </xf:action>

            <!-- Enumerated calculated value needs to get the selection list to check the default value.
                dictionaryElementValues is the list of values in the dictionary
                evaluatedSelection is either a set of nodes with @value/@displayName for selection
                or is a string that can be tokenised into the set of selectable values
                Note that if the context of the evaluation is not set, not all calculations will work.
                So need context on evaluation so that local paths are found correctly (context="$element/@value") -->
            <xf:action context="$element/@value"
                if="$element/@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedCalculatedValue'">

                <xxf:variable name="elementIRI" select="$element/@root"/>
                <xxf:variable name="dictionaryValueSelection"
                    select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$elementIRI]/iso-13606:data"/>

                <xxf:variable name="evaluatedSelection" context="$element/@value"
                    select="if (exists($element[@cityEHR:calculatedValue!=''])) then xxf:evaluate($element/@cityEHR:calculatedValue) else ()"/>

                <xxf:variable name="selectionFilter"
                    select="if ($evaluatedSelection castable as xs:string) then tokenize($evaluatedSelection,',') else ()"/>

                <xxf:variable name="elementValueSelection"
                    select="if ($evaluatedSelection instance of element()+) then $evaluatedSelection
                    else if (not(empty($selectionFilter))) then $dictionaryValueSelection[@value = $selectionFilter]
                    else ()"/>

                <xxf:variable name="selectedValue"
                    select="$elementValueSelection[@value=$defaultValue]"/>

                <xf:setvalue ref="$element/@value"
                    value="if (exists($selectedValue)) then . else ''"/>
                <xf:setvalue ref="$element/@displayName"
                    value="if (exists($selectedValue)) then $selectedValue/@displayName else ''"/>
                <xf:setvalue ref="$element/@code"
                    value="if (exists($selectedValue)) then  $selectedValue/@code else ''"/>
            </xf:action>

            <!-- Enumerated class needs to look in the class dictionary 
                TBD - need to get the class dictionary. not use the specialty dictionary -->
            <xf:action if="$element/@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedClass'">
                <!--
                    <xxf:variable name="elementId" select="$element/@extension"/>
                    <xxf:variable name="dictionaryElementClass"
                    select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@extension=$elementId][@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedClass']/iso-13606:data/@code"/>
                    <xxf:variable name="dictionaryElement"
                    select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@extension=$dictionaryElementClass][@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedValue']/iso-13606:data[@value=$defaultValue]"/>
                    <xf:action if="empty($dictionaryElement)">
                    <xf:setvalue ref="$element/@value" value="''"/>
                    </xf:action>
                    <xf:action if="exists($dictionaryElement)">
                    <xf:setvalue ref="$element/@displayName"
                    value="$dictionaryElement/@displayName"/>
                    <xf:setvalue ref="$element/@code" value="$dictionaryElement/@code"/>
                    </xf:action>
                -->
            </xf:action>

            <!-- enumeratedDirectory - look in directoryElements-instance get the element -->
            <xf:action
                if="$element/@cityEHR:elementType='#CityEHR:ElementProperty:enumeratedDirectory'">
                <xxf:variable name="elementIRI" select="$element/@root"/>
                <xxf:variable name="directoryElement"
                    select="xxf:instance('directoryElements-instance')/iso-13606:elementCollection/iso-13606:element[@root=$elementIRI]/iso-13606:data[@value=$defaultValue]"/>

                <xf:setvalue ref="$element/@value"
                    value="if (exists($directoryElement)) then . else ''"/>
                <xf:setvalue ref="$element/@displayName"
                    value="if (exists($directoryElement)) then $directoryElement/@displayName else ''"/>
                <xf:setvalue ref="$element/@code"
                    value="if (exists($directoryElement)) then  $directoryElement/@code else ''"/>
            </xf:action>


        </xf:action>

    </xf:action>


    <!-- Application defined action to expand multiple entries. 
        Iterate through each expanded multiple entry - has entry property 'Expanded' or (from 2018-04-3) 'Full'
        Find the element to expand
        Get its values from the data dictionary or calculate them (if enumeratedCalculatedValue)
        Insert an entry for each value found
        Set the value of the expanded element
    -->
    <xf:action ev:event="expand-multiple-entries">
        <!-- Get the main section (body) of the CDA document for use in processing below.
            This returns a sequence of sections on the form -->
        <xxf:variable name="cdaBody"
            select="xxf:instance('form-instance')//cda:structuredBody/cda:component/cda:section"/>

        <xf:action
            xxf:iterate="$cdaBody/descendant::cda:entry[@cityEHR:Scope=('#CityEHR:EntryProperty:Expanded','#CityEHR:EntryProperty:Full','#CityEHR:Property:Scope:Full')]/cda:organizer[@classCode='MultipleEntry']">
            <xxf:variable name="expandedEntryOrganizer" select="."/>
            <xf:dispatch name="expand-entry" target="cda-model">
                <xxf:context name="expandedEntryOrganizer" select="$expandedEntryOrganizer"/>
            </xf:dispatch>
        </xf:action>
    </xf:action>


    <!-- Application defined action to set an expanded entry.
         The complete cda:organizer is passed as a parameter (expandedEntryOrganizer)
         This contains the template entry in cda:component[1] and the set of existing entries in cda:component[2]
         Called from expand-multiple-entries and when a change to the expanded element triggers (in CDA2XForm-Module.xsl)
         enumeratedValue, enumeratedClass or enumeratedDirectory can also be constrained by a calculation
         enumeratedCalculatedValue is designed to select from a list of tokens, but is also used to constrain the set of enumerated values, if there are any
    -->
    <xf:action ev:event="expand-entry">
        <xxf:variable name="expandedEntryOrganizer" select="event('expandedEntryOrganizer')"/>
        <xxf:variable name="entryTemplate" select="$expandedEntryOrganizer/cda:component[1]"/>


        <!-- Find the expanded element (2018-04-13 there may be more than one, so use the first).
            The descendant axis takes care of enumeratedClass entries and the expanded element being inside a cluster.
            Need to use the root of the id.
            
            The expanded element can be enumeratedValue, enumeratedCalculatedValue, enumeratedClass or enumeratedDirectory.
            It must have the Scope of expanded (R1) or Full (R2) -->
        <xxf:variable name="expandedElementTemplate"
            select="($entryTemplate/descendant::cda:value[@cityEHR:Scope=('#CityEHR:ElementProperty:Expanded','#CityEHR:ElementProperty:Full')])[1]"/>
        <xxf:variable name="expandedElementIRI" select="$expandedElementTemplate/@root"/>


        <!-- If the element has a calculatedValue set, then evaluate to get the list of allowed values -->
        <xxf:variable name="calculatedValue"
            select="$expandedElementTemplate/@cityEHR:calculatedValue"/>
        <xxf:variable name="calculatedValueSet" context="$expandedElementTemplate"
            select="if (exists($calculatedValue) and $calculatedValue!='') then xxf:evaluate($calculatedValue) else ()"/>

        <!-- Get the list of values for the expanded element.
            The list depends on the e;ement type: enumeratedValue|enumeratedCalculatedValue, enumeratedClass or enumeratedDirectory -->

        <!-- Get the expanded element from the data dictionary (need to match the root attribute in the data dictionary) -->
        <xxf:variable name="dictionaryElement"
            select="xxf:instance('dictionary-instance')/iso-13606:elementCollection/iso-13606:element[@root=$expandedElementIRI]"/>
        <xxf:variable name="dictionaryElementType" select="$dictionaryElement/@cityEHR:elementType"/>


        <!-- Dictionary values -->
        <xxf:variable name="dictionaryValues"
            select="if ($dictionaryElementType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:enumeratedCalculatedValue')) then $dictionaryElement/iso-13606:data else ()"/>

        <!-- Get the class and entry node if this is an enumeratedClass element -->
        <xxf:variable name="classIRI"
            select="if ($dictionaryElementType='#CityEHR:ElementProperty:enumeratedClass') then $dictionaryElement/iso-13606:data[1]/@code else ''"/>
        <xxf:variable name="entryNodeIRI"
            select="if ($dictionaryElementType='#CityEHR:ElementProperty:enumeratedClass') then $dictionaryElement/iso-13606:data[1]/@value else ''"/>

        <!-- Get the enumerationClass here by query to class dictionary.
             Only want to do this if needed for enumeratedClass.
             Sets up enumeratedClassHierarchy-instance with the element values for enumeration -->
        <xf:action if="$dictionaryElementType='#CityEHR:ElementProperty:enumeratedClass'">
            <xf:dispatch name="update-enumeratedClassHierarchy" target="classDictionary-model">
                <xxf:context name="classCode" select="$classIRI"/>
                <xxf:context name="entryNode" select="''"/>
                <xxf:context name="elementScope" select="''"/>
            </xf:dispatch>
        </xf:action>

        <xxf:variable name="classElement"
            select="if ($classIRI!='') then xxf:instance('enumeratedClassHierarchy-instance')/descendant::iso-13606:element[@extension=$classIRI][@cityEHR:elementType=('#CityEHR:ElementProperty:enumeratedClass','#CityEHR:Property:ElementType:enumeratedClass')] else ()"/>
        <xxf:variable name="classValues"
            select="if (not(exists($classElement))) then () else if ($entryNodeIRI!=$classIRI) then $classElement/descendant::iso-13606:data[@code=$entryNodeIRI][1]/descendant::iso-13606:data[not(child::*)] else $classElement/descendant::iso-13606:data[not(child::*)]"/>

        <!-- Directory values - will be empty if the element is not enumeratedDirectory -->
        <xxf:variable name="directoryValues"
            select="xxf:instance('directoryElements-instance')/iso-13606:elementCollection/iso-13606:element[@root=$expandedElementIRI]/iso-13606:data"/>

        <!-- Get the (pre-)defined set of values for the expanded element -->
        <xxf:variable name="definedValueSet"
            select="if ($dictionaryElementType=('#CityEHR:ElementProperty:enumeratedValue','#CityEHR:ElementProperty:enumeratedCalculatedValue')) then $dictionaryValues
            else if ($dictionaryElementType='#CityEHR:ElementProperty:enumeratedClass') then $classValues
            else if ($dictionaryElementType='#CityEHR:ElementProperty:enumeratedDirectory') then $directoryValues
            else ()"/>


        <!-- Set the valueSet for the expaned element.
             If definedValueSet is empty and enumeratedCalculatedValue then set to calculatedValueSet
             else if there is a calculation then it is used to constrain the definedValueSet
             Otherwise its just the definedValueSet (which may be empty) -->
        <xxf:variable name="valueSet"
            select="if ($dictionaryElementType='#CityEHR:ElementProperty:enumeratedCalculatedValue' and empty($definedValueSet)) then $calculatedValueSet
                    else if ($calculatedValue!='') then $definedValueSet[@value = $calculatedValueSet]
                    else $definedValueSet"/>

        <!-- If there is a valueSet to expand
            The expanded ME may already contain entries.
            So there are three cases to consider:
        
            value in ME, but not in valueSet - remove it
            value in valueSet and in ME  - just leave it
            value in valueSet and not in ME - add it  -->

        <xf:action if="exists($valueSet)">

            <!-- Renove existing entries that are not in valueSet -->
            <xxf:variable name="existingEntries"
                select="$expandedEntryOrganizer/cda:component[2]/cda:organizer/cda:component"/>
            <xf:delete
                nodeset="$existingEntries[descendant::cda:value[@root=$expandedElementIRI][not(xs:string(@value)=$valueSet)]]"/>

            <!-- Iterate through the set of values for the expanded element.
             The values may be a sequence of nodes or values (in the case of enumeratedCalculatedValue, with no dictionary contraints)-->
            <xf:action xxf:iterate="$valueSet">
                <!-- The value in valueSet is either a node or an atomic value -->
                <xxf:variable name="value" select="."/>

                <!-- Insert new entry if there isn't already one for that value -->
                <xf:action
                    if="empty($expandedEntryOrganizer/cda:component[2]/cda:organizer/cda:component/descendant::cda:value[@root=$expandedElementIRI][xs:string(@value)=$value])">
                    <xf:insert context="$expandedEntryOrganizer/cda:component[2]/cda:organizer"
                        nodeset="cda:component" origin="$entryTemplate" at="last()" position="after"/>
                    <xxf:variable name="insertedEntry"
                        select="$expandedEntryOrganizer/cda:component[2]/cda:organizer/cda:component[last()]"/>

                    <!-- Set the origin attribute on the inserted entry -->
                    <xf:setvalue ref="$insertedEntry/descendant::cda:id[1]/@cityEHR:origin"
                        value="''"/>

                    <!-- Set the attributes of the expanded element (may be inside a cluster).
                 The scope of the element is set to #CityEHR:ElementProperty:Expanded (from 2018-04-13)  
                 Can be in a simple entry or an enumeratedClass entry -->
                    <xxf:variable name="insertedEntryElement"
                        select="$insertedEntry/cda:observation//cda:value[@root=$expandedElementIRI] | $insertedEntry/cda:organizer[@classCode='EnumeratedClassEntry']/cda:component[1]/cda:observation/descendant::cda:value[@root=$expandedElementIRI]"/>

                    <!-- Two cases for setting the inserted element, depending on whether $valueSet is a set of nodes or atomic values,
                 which is the case when it was set from calculatedVlaueSet -->
                    <xf:setvalue ref="$insertedEntryElement/@value"
                        value="if ($value instance of element()) then $value/@value else $value"/>
                    <xf:setvalue ref="$insertedEntryElement/@code"
                        value="if ($value instance of element()) then $value/@code else ''"/>
                    <xf:setvalue ref="$insertedEntryElement/@displayName"
                        value="if ($value instance of element()) then $value/@displayName else $value"/>

                    <!-- Set default values for the inserted entry -->
                    <xf:dispatch name="set-entry-default-values" target="cda-model">
                        <xxf:context name="entry" select="$insertedEntry"/>
                    </xf:dispatch>
                </xf:action>
            </xf:action>

        </xf:action>

        <!-- If there is not value set , then show one empty entry -->
        <xf:action if="not(exists($valueSet))">
            <xf:insert context="$expandedEntryOrganizer/cda:component[2]/cda:organizer"
                nodeset="cda:component" origin="$entryTemplate" at="last()" position="after"/>
        </xf:action>

    </xf:action>


    <!-- When the form is ready -->
    <xf:action ev:event="xforms-ready">
        <xf:rebuild model="cda-model"/>
    </xf:action>

</xf:model>
